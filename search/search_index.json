{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AI Fabric","text":"<p>AI Fabric is a coordination layer for physical systems. Robots, cameras, sensors, and industrial controllers connect to a shared Fabric mesh, expose typed functions and events, and become discoverable and controllable by AI agents \u2014 or by each other.</p> <p>There are four packages. Use the ones you need.</p>"},{"location":"#packages","title":"Packages","text":""},{"location":"#ai-fabric-device","title":"ai-fabric-device","text":"<p>The device SDK. Install this on your edge hardware \u2014 Raspberry Pi, robot, sensor, controller. Write a <code>DeviceDriver</code> subclass, decorate your methods, and the runtime handles connection, registration, heartbeats, and command routing.</p> <pre><code>pip install ai-fabric-device\n</code></pre> <pre><code>from fabric_device import DeviceRuntime\nfrom fabric_device.drivers import DeviceDriver, rpc, emit\n\nclass TemperatureSensor(DeviceDriver):\n    device_type = \"temperature_sensor\"\n\n    @rpc()\n    async def get_reading(self) -&gt; dict:\n        \"\"\"Get current temperature and humidity.\"\"\"\n        return {\"temperature_c\": 22.5, \"humidity_pct\": 45}\n\n    @emit()\n    async def threshold_alert(self, temperature_c: float, severity: str):\n        \"\"\"Temperature exceeded a threshold.\"\"\"\n        pass\n</code></pre> <p>Device Connectivity Guide \u2192</p>"},{"location":"#ai-fabric-tools","title":"ai-fabric-tools","text":"<p>The agent SDK. Install this alongside your AI agent framework. Gives your agent four tool functions to discover devices and call their functions over the mesh.</p> <pre><code>pip install ai-fabric-tools[strands]\n</code></pre> <pre><code>from ai_fabric_tools import connect\nfrom ai_fabric_tools.adapters.strands import discover_devices, invoke_device\nfrom strands import Agent\n\nconnect()\nagent = Agent(tools=[discover_devices, invoke_device])\nagent(\"What devices are online? Check the battery on any robots.\")\n</code></pre> <p>Strands Integration Guide \u2192</p>"},{"location":"#ai-fabric-agent","title":"ai-fabric-agent","text":"<p>The native agent. A batteries-included CLI daemon with inbuilt device discovery, deterministic event rules, multi-model support (Amazon Bedrock and Arm registry), LLM response caching (Redis), and goal inference from device capabilities. No code required \u2014 configure with CLI flags or a YAML file.</p> <pre><code>pip install ai-fabric-agent\n</code></pre> <pre><code>ai-fabric-agent \\\n  --model-provider bedrock \\\n  --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0 \\\n  --rules rules.yaml \\\n  --enable-caching \\\n  --goal \"Keep the warehouse temperature between 18\u00b0C and 24\u00b0C\"\n</code></pre> <p>Fabric Native Agent Guide \u2192</p>"},{"location":"#ai-fabric-core","title":"ai-fabric-core","text":"<p>The server package. Extends <code>ai-fabric-device</code> with the device registry, security (commissioning, ACLs), distributed state (etcd), audit logging (MongoDB), and CLI tools (<code>devctl</code>, <code>statectl</code>). Install this on your server or admin workstation.</p> <pre><code>pip install \"ai-fabric-core[all]\"\n</code></pre>"},{"location":"#how-it-fits-together","title":"How It Fits Together","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Native Agent\u2502       \u2502   Fabric     \u2502       \u2502   Devices    \u2502\n\u2502  / Strands   \u2502       \u2502   Server     \u2502       \u2502              \u2502\n\u2502  Agent       \u2502       \u2502              \u2502       \u2502  robot-001   \u2502\n\u2502              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Fabric Mesh \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2502  camera-002  \u2502\n\u2502  ai-fabric-  \u2502 JSON- \u2502  Registry    \u2502 self- \u2502  sensor-003  \u2502\n\u2502  agent or    \u2502 RPC   \u2502  etcd        \u2502 reg.  \u2502              \u2502\n\u2502  ai-fabric-  \u2502       \u2502              \u2502       \u2502  ai-fabric-  \u2502\n\u2502  tools       \u2502       \u2502  ai-fabric-  \u2502       \u2502  device      \u2502\n\u2502              \u2502       \u2502  core        \u2502       \u2502              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Devices run <code>ai-fabric-device</code>, connect to the Fabric mesh, self-register, and expose <code>@rpc</code> functions and <code>@emit</code> events.</p> <p>Agents run <code>ai-fabric-agent</code> (native agent) or <code>ai-fabric-tools</code> (Strands/LangChain), discover devices on the mesh, and invoke their functions as part of the agent's reasoning loop.</p> <p>The server runs <code>ai-fabric-core</code> with the Fabric mesh (messaging), etcd (state), and the device registry. It routes messages and tracks which devices are online.</p> <p>No component knows about the internals of the other. Devices don't know they're being called by an AI agent. Agents don't know what protocol the device uses internally. The Fabric mesh handles the routing.</p>"},{"location":"agent-integration/","title":"Fabric Agent Integration","text":"<p>Give your AI agent the ability to discover and control physical devices on a Fabric mesh using <code>ai-fabric-tools</code>.</p> <p><code>ai-fabric-tools</code> is the agent-side SDK. It provides four tool functions that any agent framework can use \u2014 Strands, LangChain, or plain Python. The tools connect to NATS, query the device registry, and invoke device functions over JSON-RPC.</p>"},{"location":"agent-integration/#installation","title":"Installation","text":"<pre><code># Core (plain Python tools, no framework dependency)\npip install ai-fabric-tools\n\n# With Strands adapter\npip install \"ai-fabric-tools[strands]\"\n\n# With LangChain adapter\npip install \"ai-fabric-tools[langchain]\"\n</code></pre> Extra What it adds (none) Core tools + NATS client (<code>nats-py</code>, <code>nkeys</code>) <code>strands</code> <code>strands-agents</code> \u2014 Strands <code>@tool</code> wrappers <code>langchain</code> <code>langchain-core</code> \u2014 LangChain <code>StructuredTool</code> wrappers"},{"location":"agent-integration/#connecting-to-the-mesh","title":"Connecting to the Mesh","text":"<p>Before using any tools, call <code>connect()</code> to establish the NATS connection. The connection is a thread-safe singleton \u2014 call it once at startup.</p> <pre><code>from ai_fabric_tools import connect\n\nconnect()\n</code></pre>"},{"location":"agent-integration/#connection-resolution-order","title":"Connection Resolution Order","text":"<p>Each setting (NATS URL, credentials, TLS, tenant) resolves in this order:</p> <ol> <li>Explicit parameter passed to <code>connect()</code></li> <li>Environment variable</li> <li>Auto-discovery from well-known paths</li> </ol>"},{"location":"agent-integration/#connect-parameters","title":"connect() Parameters","text":"<pre><code>connect(\n    nats_url=\"nats://your-server:4222\",\n    zone=\"default\",\n    credentials=\"/path/to/agent.creds.json\",\n    tls_config={\"ca\": \"/path/to/ca-cert.pem\"},\n    request_timeout=30.0,\n)\n</code></pre> Parameter Type Description Default <code>nats_url</code> <code>str</code> NATS broker URL From env or auto-discovery <code>zone</code> <code>str</code> Fabric tenant/namespace <code>\"default\"</code> <code>credentials</code> <code>str \\| dict</code> Path to <code>.creds.json</code> or credentials dict From env or auto-discovery <code>tls_config</code> <code>dict</code> TLS configuration (CA cert, client cert/key) From env or auto-discovery <code>request_timeout</code> <code>float</code> Default timeout in seconds for device RPC calls <code>30.0</code>"},{"location":"agent-integration/#environment-variables","title":"Environment Variables","text":"Variable Description Example <code>NATS_URL</code> NATS broker URL <code>nats://your-server:4222</code> <code>NATS_CREDENTIALS_FILE</code> Path to credentials JSON file <code>/home/agent/.fabric/agent.creds.json</code> <code>NATS_JWT</code> JWT token (alternative to credentials file) <code>eyJ0eXAiOiJKV1Qi...</code> <code>NATS_NKEY_SEED</code> NKey seed (used with <code>NATS_JWT</code>) <code>SUAE...</code> <code>NATS_TLS_CA_FILE</code> CA certificate for TLS <code>/etc/fabric/ca-cert.pem</code> <code>NATS_TLS_CERT_FILE</code> Client certificate for mTLS <code>/etc/fabric/client-cert.pem</code> <code>NATS_TLS_KEY_FILE</code> Client key for mTLS <code>/etc/fabric/client-key.pem</code> <code>TENANT</code> Fabric zone/namespace <code>warehouse-east</code>"},{"location":"agent-integration/#auto-discovery","title":"Auto-Discovery","text":"<p>If no explicit parameters or environment variables are set, <code>connect()</code> walks up from the current working directory looking for a <code>security_infra/</code> directory containing credentials and TLS certificates. This means <code>connect()</code> with no arguments works when run from anywhere inside a Fabric project tree.</p> <p>Search paths:</p> <ul> <li><code>./security_infra/credentials/</code> \u2014 credential files (<code>orchestrator.creds.json</code>, <code>devctl.creds.json</code>)</li> <li><code>./security_infra/certs/</code> \u2014 CA and client certificates</li> <li><code>../security_infra/</code>, <code>../../security_infra/</code>, etc. \u2014 walks up the directory tree</li> </ul>"},{"location":"agent-integration/#connection-examples","title":"Connection Examples","text":"Environment VariablesExplicit ParametersAuto-Discovery <pre><code>export NATS_URL=nats://your-server:4222\nexport NATS_CREDENTIALS_FILE=/home/agent/.fabric/agent.creds.json\nexport TENANT=default\n</code></pre> <pre><code>from ai_fabric_tools import connect\nconnect()  # picks up env vars automatically\n</code></pre> <pre><code>from ai_fabric_tools import connect\nconnect(\n    nats_url=\"nats://your-server:4222\",\n    credentials=\"/home/agent/.fabric/agent.creds.json\",\n    zone=\"warehouse-east\",\n)\n</code></pre> <pre><code># Run from anywhere inside your Fabric project\ncd /home/user/my-fabric-project/agents/\npython my_agent.py\n</code></pre> <pre><code>from ai_fabric_tools import connect\nconnect()  # finds security_infra/ automatically\n</code></pre>"},{"location":"agent-integration/#disconnect","title":"Disconnect","text":"<pre><code>from ai_fabric_tools import disconnect\ndisconnect()  # closes NATS connection and releases resources\n</code></pre>"},{"location":"agent-integration/#tool-functions","title":"Tool Functions","text":"<p><code>ai-fabric-tools</code> provides four tool functions. These are plain Python functions \u2014 they work without any agent framework.</p> <pre><code>from ai_fabric_tools import (\n    discover_devices,\n    invoke_device,\n    invoke_device_with_fallback,\n    get_device_status,\n)\n</code></pre>"},{"location":"agent-integration/#discover_devices","title":"discover_devices","text":"<p>See what devices are on the mesh, what functions they expose, and what events they emit.</p> <pre><code>devices = discover_devices()\nrobots = discover_devices(device_type=\"robot\")\n</code></pre> Parameter Type Description Default <code>device_type</code> <code>str \\| None</code> Filter by type (fuzzy match \u2014 <code>\"robot\"</code> matches <code>\"cleaning_robot\"</code>) <code>None</code> (all) <code>refresh</code> <code>bool</code> Bypass cache and query registry directly <code>False</code> <p>Returns a list of device dicts:</p> <pre><code>[\n    {\n        \"device_id\": \"robot-001\",\n        \"device_type\": \"cleaning_robot\",\n        \"location\": \"warehouse-B\",\n        \"status\": {\"availability\": \"available\"},\n        \"functions\": [\n            {\n                \"name\": \"start_cleaning\",\n                \"description\": \"Start cleaning a specified zone.\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"zone\": {\"type\": \"string\"},\n                        \"priority\": {\"type\": \"string\", \"default\": \"normal\"}\n                    }\n                }\n            }\n        ],\n        \"events\": [\"cleaning_complete\", \"battery_low\"]\n    }\n]\n</code></pre> <p>The function schemas come directly from the device driver's <code>@rpc()</code> decorated methods \u2014 their names, docstrings, and type hints. No manual schema authoring needed.</p>"},{"location":"agent-integration/#invoke_device","title":"invoke_device","text":"<p>Call a function on a specific device.</p> <pre><code>result = invoke_device(\n    device_id=\"robot-001\",\n    function=\"start_cleaning\",\n    params={\"zone\": \"zone-A\"},\n    llm_reasoning=\"Camera detected spill in zone-A\",\n)\n</code></pre> Parameter Type Description Default <code>device_id</code> <code>str</code> Target device ID required <code>function</code> <code>str</code> Function name to call required <code>params</code> <code>dict \\| None</code> Function parameters (check <code>discover_devices</code> for schemas) <code>None</code> <code>llm_reasoning</code> <code>str \\| None</code> Why the agent is making this call \u2014 logged for observability <code>None</code> <p>Returns:</p> <pre><code># Success\n{\"success\": True, \"result\": {\"zone\": \"zone-A\", \"status\": \"cleaning_in_progress\"}}\n\n# Failure\n{\"success\": False, \"error\": \"Device robot-001 is offline\"}\n</code></pre> <p>The <code>llm_reasoning</code> field is never sent to the device. It's logged on the agent side so you can trace back why the model made a particular call.</p>"},{"location":"agent-integration/#invoke_device_with_fallback","title":"invoke_device_with_fallback","text":"<p>Same as <code>invoke_device</code>, but tries a list of devices in order until one succeeds.</p> <pre><code>result = invoke_device_with_fallback(\n    device_ids=[\"robot-001\", \"robot-002\", \"robot-003\"],\n    function=\"start_cleaning\",\n    params={\"zone\": \"zone-A\"},\n    llm_reasoning=\"Need any available robot for zone-A spill\",\n)\n</code></pre> Parameter Type Description Default <code>device_ids</code> <code>list[str]</code> Devices to try, in preference order required <code>function</code> <code>str</code> Function name to call required <code>params</code> <code>dict \\| None</code> Function parameters <code>None</code> <code>llm_reasoning</code> <code>str \\| None</code> Decision rationale <code>None</code> <p>Returns:</p> <pre><code># Second device succeeded\n{\"success\": True, \"device_id\": \"robot-002\", \"result\": {\"status\": \"cleaning\"}}\n\n# All failed\n{\n    \"success\": False,\n    \"error\": \"All devices failed\",\n    \"failed_devices\": [\n        {\"device_id\": \"robot-001\", \"error\": \"offline\"},\n        {\"device_id\": \"robot-002\", \"error\": \"timeout\"},\n        {\"device_id\": \"robot-003\", \"error\": \"busy\"}\n    ]\n}\n</code></pre>"},{"location":"agent-integration/#get_device_status","title":"get_device_status","text":"<p>Check a single device's current state.</p> <pre><code>status = get_device_status(device_id=\"robot-001\")\n</code></pre> Parameter Type Description Default <code>device_id</code> <code>str</code> Device to query required <p>Returns:</p> <pre><code>{\n    \"device_id\": \"robot-001\",\n    \"device_type\": \"cleaning_robot\",\n    \"location\": \"warehouse-B\",\n    \"status\": {\"availability\": \"available\"},\n    \"functions\": [\"start_cleaning\", \"stop_cleaning\", \"get_battery_level\"]\n}\n</code></pre>"},{"location":"agent-integration/#using-with-agent-frameworks","title":"Using with Agent Frameworks","text":"<p>The core tool functions are plain Python. To use them with an agent framework, import from the corresponding adapter \u2014 each adapter wraps the same four functions with the framework's tool decorator.</p>"},{"location":"agent-integration/#strands","title":"Strands","text":"<pre><code>from ai_fabric_tools import connect\nfrom ai_fabric_tools.adapters.strands import (\n    discover_devices,\n    invoke_device,\n    invoke_device_with_fallback,\n    get_device_status,\n)\nfrom strands import Agent\n\nconnect()\n\nagent = Agent(\n    tools=[discover_devices, invoke_device],\n    system_prompt=\"You monitor and control IoT devices.\",\n)\nagent(\"What devices are online?\")\n</code></pre>"},{"location":"agent-integration/#langchain","title":"LangChain","text":"<pre><code>from ai_fabric_tools import connect\nfrom ai_fabric_tools.adapters.langchain import (\n    discover_devices,\n    invoke_device,\n)\nfrom langchain_anthropic import ChatAnthropic\nfrom langgraph.prebuilt import create_react_agent\n\nconnect()\n\nmodel = ChatAnthropic(model=\"claude-sonnet-4-5-20250929\")\nagent = create_react_agent(model, [discover_devices, invoke_device])\nagent.invoke({\"messages\": [{\"role\": \"user\", \"content\": \"List all devices\"}]})\n</code></pre>"},{"location":"agent-integration/#plain-python-no-framework","title":"Plain Python (No Framework)","text":"<pre><code>from ai_fabric_tools import connect, discover_devices, invoke_device\n\nconnect()\n\n# Use directly \u2014 no agent needed\ndevices = discover_devices()\nfor d in devices:\n    if d[\"device_type\"] == \"temperature_sensor\":\n        reading = invoke_device(d[\"device_id\"], \"get_reading\")\n        print(f\"{d['device_id']}: {reading}\")\n</code></pre>"},{"location":"agent-integration/#writing-a-custom-adapter","title":"Writing a Custom Adapter","text":"<p>If your framework isn't covered, writing an adapter is four lines per tool:</p> <pre><code>from your_framework import tool_decorator\nfrom ai_fabric_tools.tools import (\n    discover_devices as _discover_devices,\n    invoke_device as _invoke_device,\n    invoke_device_with_fallback as _invoke_device_with_fallback,\n    get_device_status as _get_device_status,\n)\n\ndiscover_devices = tool_decorator(_discover_devices)\ninvoke_device = tool_decorator(_invoke_device)\ninvoke_device_with_fallback = tool_decorator(_invoke_device_with_fallback)\nget_device_status = tool_decorator(_get_device_status)\n</code></pre> <p>The core functions carry their own names, docstrings, type hints, and parameter schemas. Most framework decorators pick these up automatically.</p>"},{"location":"agent-integration/#event-subscriptions","title":"Event Subscriptions","text":"<p>The four tool functions are stateless request-reply operations. For real-time event streams from devices, use the connection object directly:</p> <pre><code>import asyncio\nfrom ai_fabric_tools import connect, get_connection\n\nconnect()\nconn = get_connection()\n\nasync def watch_events():\n    async for batch in conn.subscribe_events(batch_window=10.0):\n        for event in batch:\n            print(f\"{event['device_id']}::{event['event_name']} \u2192 {event['params']}\")\n\nasyncio.run(watch_events())\n</code></pre> Parameter Type Description Default <code>batch_window</code> <code>float</code> Seconds to collect events before yielding a batch <code>12.0</code> <code>device_id</code> <code>str \\| None</code> Filter events from a specific device <code>None</code> (all) <p>For subscribing to specific NATS subjects:</p> <pre><code>conn = get_connection()\n\nasync def on_message(msg):\n    print(f\"Received: {msg.data.decode()}\")\n\nawait conn.async_subscribe(\"fabric.default.robot-001.event.&gt;\", on_message)\n</code></pre>"},{"location":"agent-integration/#access-control","title":"Access Control","text":"<p>Credentials determine what your agent can see and do. A credential scoped to <code>warehouse-east</code> will:</p> <ul> <li><code>discover_devices</code> \u2014 only returns warehouse-east devices</li> <li><code>invoke_device</code> \u2014 calls to out-of-scope devices return an authorization error</li> <li><code>get_device_status</code> \u2014 same scoping</li> </ul> <p>This is enforced at the NATS layer, not in the SDK. The tools don't filter \u2014 the messaging infrastructure does.</p>"},{"location":"agent-integration/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Your Agent (Strands, LangChain, plain Python)      \u2502\n\u2502                                                     \u2502\n\u2502  from ai_fabric_tools.adapters.strands import ...   \u2502\n\u2502        \u2502                                            \u2502\n\u2502        \u25bc                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502  \u2502  Adapter Layer (4 lines per tool)   \u2502            \u2502\n\u2502  \u2502  strands_tool(_discover_devices)    \u2502            \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502                 \u2502                                    \u2502\n\u2502        \u25bc                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502  \u2502  Core Tool Functions (plain Python) \u2502            \u2502\n\u2502  \u2502  discover_devices()                 \u2502            \u2502\n\u2502  \u2502  invoke_device()                    \u2502            \u2502\n\u2502  \u2502  invoke_device_with_fallback()      \u2502            \u2502\n\u2502  \u2502  get_device_status()                \u2502            \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502                 \u2502                                    \u2502\n\u2502        \u25bc                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502  \u2502  Connection (singleton, thread-safe)\u2502            \u2502\n\u2502  \u2502  NATS client + sync-to-async bridge \u2502            \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502 JSON-RPC over NATS\n                  \u25bc\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502   NATS Server   \u2502\n         \u2502   + JWT Auth     \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u25bc            \u25bc            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502robot   \u2502 \u2502camera  \u2502 \u2502sensor  \u2502\n\u2502-001    \u2502 \u2502-002    \u2502 \u2502-003    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The adapter layer is intentionally thin \u2014 one function call per tool. All logic lives in the core functions. The connection manages a dedicated asyncio event loop on a daemon thread, bridging sync tool calls to the async NATS client.</p>"},{"location":"device-connectivity/","title":"Device Connectivity to Fabric","text":"<p>You manufacture a device \u2014 a robot, a sensor, a camera, a controller. You want it to be discoverable and controllable by AI agents and other devices on a Fabric mesh.</p> <p>This page shows you how to write a device driver, connect your device to the Fabric mesh, and expose typed functions and events that agents can discover and call.</p>"},{"location":"device-connectivity/#what-your-device-becomes","title":"What Your Device Becomes","text":"<p>Once connected, your device:</p> <ul> <li>Self-registers with the device registry (device type, functions, events, identity)</li> <li>Maintains a heartbeat so the mesh knows it's alive</li> <li>Receives RPC calls from agents or other devices (JSON-RPC over the Fabric mesh)</li> <li>Emits events that agents and other devices can subscribe to</li> <li>Communicates device-to-device without going through a central orchestrator</li> </ul> <p>You write the device logic. The runtime handles registration, heartbeats, messaging, and command routing.</p>"},{"location":"device-connectivity/#installation","title":"Installation","text":"<pre><code>pip install ai-fabric-device\n</code></pre> <p>Four dependencies: <code>nats-py</code>, <code>pydantic</code>, <code>nkeys</code>, <code>pyyaml</code>. Runs on a Raspberry Pi.</p> <p>Optional: <code>pip install \"ai-fabric-device[telemetry]\"</code> adds OpenTelemetry distributed tracing.</p>"},{"location":"device-connectivity/#your-first-device","title":"Your First Device","text":"<p>A complete working device in one file. This temperature sensor exposes one RPC function and emits one event:</p> <pre><code>import asyncio\nfrom fabric_device import DeviceRuntime\nfrom fabric_device.drivers import DeviceDriver, rpc, emit\nfrom fabric_device.types import DeviceIdentity, DeviceStatus\n\n\nclass TemperatureSensor(DeviceDriver):\n    device_type = \"temperature_sensor\"\n\n    @property\n    def identity(self) -&gt; DeviceIdentity:\n        return DeviceIdentity(\n            device_type=\"temperature_sensor\",\n            manufacturer=\"Acme Sensors\",\n            model=\"TH-200\",\n            firmware_version=\"2.1.0\",\n            description=\"Industrial temperature and humidity sensor\",\n        )\n\n    @property\n    def status(self) -&gt; DeviceStatus:\n        return DeviceStatus(\n            location=\"warehouse-B\",\n            availability=\"available\",\n        )\n\n    @rpc()\n    async def get_reading(self) -&gt; dict:\n        \"\"\"Get current temperature and humidity.\n\n        Returns:\n            Dictionary with temperature_c, humidity_pct, and unit.\n        \"\"\"\n        # Replace with your actual hardware read\n        return {\"temperature_c\": 22.5, \"humidity_pct\": 45, \"unit\": \"celsius\"}\n\n    @emit()\n    async def threshold_alert(self, temperature_c: float, threshold: float, severity: str):\n        \"\"\"Temperature exceeded a configured threshold.\n\n        Args:\n            temperature_c: Current temperature reading.\n            threshold: The threshold that was crossed.\n            severity: Alert severity \u2014 warning or critical.\n        \"\"\"\n        pass\n\n    async def connect(self) -&gt; None:\n        # Initialize your hardware, open serial ports, etc.\n        pass\n\n    async def disconnect(self) -&gt; None:\n        # Clean up hardware resources\n        pass\n\n\nasync def main():\n    device = DeviceRuntime(\n        driver=TemperatureSensor(),\n        device_id=\"temp-sensor-001\",\n        messaging_urls=[\"nats://your-server:4222\"],\n        nats_credentials_file=\"/path/to/temp-sensor-001.creds.json\",\n    )\n    await device.run()\n\n\nasyncio.run(main())\n</code></pre> <p>When this runs:</p> <ol> <li>Connects to the Fabric mesh with JWT authentication</li> <li>Registers with the device registry: \"I am temp-sensor-001, type temperature_sensor, I have <code>get_reading</code> and <code>threshold_alert</code>\"</li> <li>Starts sending heartbeats</li> <li>Listens for incoming RPC calls on <code>fabric.default.temp-sensor-001.cmd</code></li> <li>When an agent calls <code>invoke_device(\"temp-sensor-001\", \"get_reading\")</code>, your <code>get_reading</code> method executes and the result is sent back</li> </ol>"},{"location":"device-connectivity/#writing-a-device-driver","title":"Writing a Device Driver","text":"<p>Your driver is a Python class that extends <code>DeviceDriver</code>. Everything the device can do is declared with decorators.</p>"},{"location":"device-connectivity/#device-identity-and-status","title":"Device Identity and Status","text":"<p>Every device reports who it is and what state it's in. Agents see this when they call <code>discover_devices</code>.</p> <pre><code>from fabric_device.types import DeviceIdentity, DeviceStatus\n\nclass MyRobot(DeviceDriver):\n    device_type = \"cleaning_robot\"\n\n    @property\n    def identity(self) -&gt; DeviceIdentity:\n        return DeviceIdentity(\n            device_type=\"cleaning_robot\",\n            manufacturer=\"RoboCorp\",\n            model=\"CleanBot-3000\",\n            firmware_version=\"4.2.1\",\n            arch=\"aarch64\",\n            description=\"Autonomous floor cleaning robot with chemical handling\",\n        )\n\n    @property\n    def status(self) -&gt; DeviceStatus:\n        return DeviceStatus(\n            location=\"building-A-floor-2\",\n            availability=\"available\",  # or \"busy\", \"offline\", \"maintenance\"\n        )\n</code></pre>"},{"location":"device-connectivity/#rpc-functions-agents-can-call","title":"@rpc \u2014 Functions Agents Can Call","text":"<p>Mark any async method with <code>@rpc()</code> to make it callable over the mesh. The method's name, docstring, and type hints are automatically converted into a function schema that agents can read.</p> <pre><code>from fabric_device.drivers import DeviceDriver, rpc\n\nclass MyRobot(DeviceDriver):\n    device_type = \"cleaning_robot\"\n\n    @rpc()\n    async def start_cleaning(self, zone: str, priority: str = \"normal\") -&gt; dict:\n        \"\"\"Start cleaning a specified zone.\n\n        Args:\n            zone: Target zone ID (e.g., \"zone-A\", \"loading-dock\").\n            priority: Cleaning priority \u2014 normal or urgent.\n\n        Returns:\n            Dictionary with status and estimated_duration_minutes.\n        \"\"\"\n        await self._hardware.start(zone, priority)\n        return {\"status\": \"cleaning\", \"estimated_duration_minutes\": 15}\n\n    @rpc()\n    async def get_battery_level(self) -&gt; dict:\n        \"\"\"Get current battery percentage.\n\n        Returns:\n            Dictionary with battery_pct and charging status.\n        \"\"\"\n        return {\"battery_pct\": 80, \"charging\": False}\n\n    @rpc()\n    async def emergency_stop(self) -&gt; dict:\n        \"\"\"Immediately stop all movement and operations.\n\n        Returns:\n            Dictionary with confirmation status.\n        \"\"\"\n        await self._hardware.halt()\n        return {\"status\": \"stopped\"}\n</code></pre> <p>An agent that calls <code>discover_devices(device_type=\"cleaning_robot\")</code> will see:</p> <pre><code>{\n  \"functions\": [\n    {\n      \"name\": \"start_cleaning\",\n      \"description\": \"Start cleaning a specified zone.\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"zone\": {\"type\": \"string\", \"description\": \"Target zone ID\"},\n          \"priority\": {\"type\": \"string\", \"default\": \"normal\"}\n        }\n      }\n    },\n    {\n      \"name\": \"get_battery_level\",\n      \"description\": \"Get current battery percentage.\"\n    },\n    {\n      \"name\": \"emergency_stop\",\n      \"description\": \"Immediately stop all movement and operations.\"\n    }\n  ]\n}\n</code></pre> <p>Docstrings Matter</p> <p>The function name, docstring, and <code>Args:</code> descriptions are what the AI agent reads to decide when and how to call your function. Write them like you're explaining the function to a person. Clear descriptions lead to better agent decisions.</p>"},{"location":"device-connectivity/#emit-events-your-device-publishes","title":"@emit \u2014 Events Your Device Publishes","text":"<p>Mark a method with <code>@emit()</code> to declare an event. Call the method from your code to publish it. Agents and other devices can subscribe.</p> <pre><code>from fabric_device.drivers import DeviceDriver, emit\n\nclass MyRobot(DeviceDriver):\n    device_type = \"cleaning_robot\"\n\n    @emit()\n    async def cleaning_complete(self, zone: str, duration_minutes: float):\n        \"\"\"Cleaning finished in a zone.\n\n        Args:\n            zone: Zone that was cleaned.\n            duration_minutes: How long the cleaning took.\n        \"\"\"\n        pass  # the body is empty \u2014 the runtime handles publishing\n\n    @emit()\n    async def battery_low(self, battery_pct: int):\n        \"\"\"Battery dropped below threshold.\n\n        Args:\n            battery_pct: Current battery percentage.\n        \"\"\"\n        pass\n</code></pre> <p>Emit events from anywhere in your driver:</p> <pre><code>await self.cleaning_complete(zone=\"zone-A\", duration_minutes=12.5)\nawait self.battery_low(battery_pct=15)\n</code></pre> <p>Events are published to <code>fabric.{tenant}.{device_id}.event.{event_name}</code> on the Fabric mesh. Any subscriber \u2014 agent or device \u2014 receives them.</p>"},{"location":"device-connectivity/#periodic-background-tasks","title":"@periodic \u2014 Background Tasks","text":"<p>Run a method on a fixed interval. Useful for polling sensors, emitting telemetry, or running health checks.</p> <pre><code>from fabric_device.drivers import DeviceDriver, rpc, emit, periodic\n\nclass TemperatureSensor(DeviceDriver):\n    device_type = \"temperature_sensor\"\n\n    @emit()\n    async def reading(self, temperature_c: float, humidity_pct: float):\n        \"\"\"A new sensor reading.\"\"\"\n        pass\n\n    @emit()\n    async def threshold_alert(self, temperature_c: float, threshold: float, severity: str):\n        \"\"\"Temperature exceeded a threshold.\"\"\"\n        pass\n\n    @periodic(interval=10.0)\n    async def poll_sensor(self):\n        \"\"\"Read sensor every 10 seconds and emit events.\"\"\"\n        data = await self._read_hardware()\n        await self.reading(temperature_c=data[\"temp\"], humidity_pct=data[\"humidity\"])\n\n        if data[\"temp\"] &gt; 40.0:\n            await self.threshold_alert(\n                temperature_c=data[\"temp\"],\n                threshold=40.0,\n                severity=\"critical\",\n            )\n\n    @periodic(interval=60.0)\n    async def health_check(self):\n        \"\"\"Run self-diagnostics every minute.\"\"\"\n        if not self._hardware.is_healthy():\n            self.logger.warning(\"Hardware health check failed\")\n</code></pre>"},{"location":"device-connectivity/#on-listen-to-other-devices","title":"@on \u2014 Listen to Other Devices","text":"<p>Subscribe to events from other devices on the mesh. Your device can react to what's happening around it without going through a central agent.</p> <pre><code>from fabric_device.drivers import DeviceDriver, rpc, on\n\nclass CleaningRobot(DeviceDriver):\n    device_type = \"cleaning_robot\"\n\n    @on(device_type=\"camera\", event_name=\"spill_detected\")\n    async def on_spill(self, device_id: str, event_name: str, payload: dict):\n        \"\"\"React when any camera detects a spill.\"\"\"\n        zone = payload.get(\"zone\")\n        self.logger.info(f\"Spill detected by {device_id} in {zone}\")\n        await self.start_cleaning(zone=zone)\n\n    @on(device_type=\"cleaning_robot\", event_name=\"cleaning_complete\")\n    async def on_peer_done(self, device_id: str, event_name: str, payload: dict):\n        \"\"\"Track when other robots finish cleaning.\"\"\"\n        self.logger.info(f\"{device_id} finished cleaning {payload.get('zone')}\")\n\n    @rpc()\n    async def start_cleaning(self, zone: str) -&gt; dict:\n        \"\"\"Start cleaning a zone.\"\"\"\n        return {\"status\": \"cleaning\", \"zone\": zone}\n</code></pre> <p>This is device-to-device communication. No agent involved. The camera emits <code>spill_detected</code>, the robot receives it directly over the Fabric mesh and acts.</p>"},{"location":"device-connectivity/#before_emit-intercept-events","title":"@before_emit \u2014 Intercept Events","text":"<p>Filter or modify events before they're published. Return <code>False</code> to suppress an event.</p> <pre><code>from fabric_device.drivers import DeviceDriver, emit, before_emit\n\nclass NoisySensor(DeviceDriver):\n    device_type = \"sensor\"\n\n    @emit()\n    async def reading(self, value: float):\n        \"\"\"A sensor reading.\"\"\"\n        pass\n\n    @before_emit(\"reading\")\n    async def filter_noise(self, value: float, **kwargs):\n        \"\"\"Suppress readings that haven't changed significantly.\"\"\"\n        if hasattr(self, \"_last_value\") and abs(value - self._last_value) &lt; 0.5:\n            return False  # suppress \u2014 don't publish\n        self._last_value = value\n</code></pre>"},{"location":"device-connectivity/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>Every driver has <code>connect</code> and <code>disconnect</code>. Use them to initialize and clean up hardware resources.</p> <pre><code>class MyRobot(DeviceDriver):\n    device_type = \"robot\"\n\n    async def connect(self) -&gt; None:\n        \"\"\"Called after Fabric mesh connection is established, before RPCs start.\"\"\"\n        self._hardware = await RobotSDK.connect(\"/dev/ttyUSB0\")\n        self.logger.info(\"Hardware initialized\")\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Called during shutdown, before Fabric mesh disconnects.\"\"\"\n        await self._hardware.close()\n        self.logger.info(\"Hardware released\")\n</code></pre>"},{"location":"device-connectivity/#running-the-device","title":"Running the Device","text":""},{"location":"device-connectivity/#deviceruntime","title":"DeviceRuntime","text":"<p><code>DeviceRuntime</code> handles everything outside your driver logic: Fabric mesh connection, JWT authentication, device registration, heartbeats, command routing.</p> <pre><code>from fabric_device import DeviceRuntime\n\ndevice = DeviceRuntime(\n    driver=MyRobot(),\n    device_id=\"robot-001\",\n    messaging_urls=[\"nats://your-server:4222\"],\n    nats_credentials_file=\"~/.fabric/credentials/robot-001.creds.json\",\n    tenant=\"default\",\n)\nawait device.run()\n</code></pre> Parameter Type Description <code>driver</code> <code>DeviceDriver</code> Your driver instance <code>device_id</code> <code>str</code> Unique device identifier on the mesh <code>messaging_urls</code> <code>list[str]</code> Fabric mesh URLs <code>nats_credentials_file</code> <code>str \\| None</code> Path to <code>.creds.json</code> for JWT auth <code>tenant</code> <code>str</code> Namespace / zone (default: <code>\"default\"</code>) <code>allow_insecure</code> <code>bool</code> Skip auth for local development (default: <code>False</code>)"},{"location":"device-connectivity/#credentials","title":"Credentials","text":"<p>Devices authenticate to the Fabric mesh using JWT + NKey credentials. A <code>.creds.json</code> file:</p> <pre><code>{\n  \"device_id\": \"robot-001\",\n  \"auth_type\": \"jwt\",\n  \"tenant\": \"default\",\n  \"nats\": {\n    \"urls\": [\"nats://your-server:4222\"],\n    \"jwt\": \"eyJ0eXAiOiJKV1Qi...\",\n    \"nkey_seed\": \"SUAE...\"\n  }\n}\n</code></pre> <p>Credentials are provisioned by the Fabric administrator and determine:</p> <ul> <li>Which subjects the device can publish/subscribe to on the Fabric mesh</li> <li>Which tenant namespace it operates in</li> <li>Its identity for JWT authentication</li> </ul> <p>Development Mode</p> <p>For local development without auth, use <code>allow_insecure=True</code>. Never use this in production.</p> <pre><code>device = DeviceRuntime(\n    driver=MyRobot(),\n    device_id=\"robot-001\",\n    messaging_urls=[\"nats://localhost:4222\"],\n    allow_insecure=True,\n)\n</code></pre>"},{"location":"device-connectivity/#device-to-device-communication","title":"Device-to-Device Communication","text":"<p>Every <code>DeviceDriver</code> has built-in methods for talking to other devices on the mesh. No agent required.</p>"},{"location":"device-connectivity/#invoke_remote-call-another-device","title":"invoke_remote \u2014 Call Another Device","text":"<pre><code>class Camera(DeviceDriver):\n    device_type = \"camera\"\n\n    @rpc()\n    async def on_motion(self, zone: str) -&gt; dict:\n        \"\"\"Motion detected \u2014 dispatch a robot.\"\"\"\n        robots = await self.list_devices(device_type=\"cleaning_robot\")\n        if robots:\n            result = await self.invoke_remote(\n                robots[0][\"device_id\"],\n                \"start_cleaning\",\n                zone=zone,\n            )\n            return {\"dispatched\": True, \"result\": result}\n        return {\"dispatched\": False, \"reason\": \"no robots available\"}\n</code></pre>"},{"location":"device-connectivity/#list_devices-query-the-registry","title":"list_devices \u2014 Query the Registry","text":"<pre><code># All devices\nall_devices = await self.list_devices()\n\n# Filter by type\nrobots = await self.list_devices(device_type=\"cleaning_robot\")\n\n# Filter by location\nlocal = await self.list_devices(location=\"building-A\")\n</code></pre>"},{"location":"device-connectivity/#what-happens-at-runtime","title":"What Happens at Runtime","text":"<p>When <code>device.run()</code> is called, this is the sequence:</p> <ol> <li>Connect to Fabric mesh \u2014 authenticates with JWT + NKey</li> <li>Connect driver \u2014 calls your <code>connect()</code> method</li> <li>Register \u2014 sends device identity, functions, and events to the registry</li> <li>Subscribe to commands \u2014 listens on <code>fabric.{tenant}.{device_id}.cmd</code></li> <li>Start periodic tasks \u2014 any <code>@periodic</code> methods begin running</li> <li>Start event subscriptions \u2014 any <code>@on</code> handlers are wired up</li> <li>Heartbeat loop \u2014 periodic heartbeats keep the registration alive</li> </ol> <p>From this point, your device is live on the mesh. Agents can discover it and call its functions. Other devices can send it events. Your periodic tasks run in the background.</p> <p>When <code>device.stop()</code> is called (or Ctrl+C):</p> <ol> <li>Periodic tasks stop</li> <li>Event subscriptions tear down</li> <li>Your <code>disconnect()</code> method runs</li> <li>Fabric mesh connection closes</li> </ol>"},{"location":"device-connectivity/#decorator-summary","title":"Decorator Summary","text":"Decorator What it does <code>@rpc()</code> Expose a method as a remotely callable function (agent or D2D) <code>@emit()</code> Declare an event that can be published to subscribers <code>@periodic(interval=N)</code> Run a method every N seconds in the background <code>@on(device_type=..., event_name=...)</code> Subscribe to events from other devices <code>@before_emit(\"event_name\")</code> Intercept and filter/modify an event before publishing"},{"location":"device-connectivity/#deployment","title":"Deployment","text":""},{"location":"device-connectivity/#pre-packaged-docker-container","title":"Pre-Packaged Docker Container","text":"<p>Package your device driver into a Docker image and push it to your container registry. New devices \u2014 whether cloud VMs, edge servers, or Raspberry Pis \u2014 pull the image and run. No Python install, no pip, no manual setup.</p> <p>Dockerfile:</p> <pre><code>FROM python:3.11-slim\n\nWORKDIR /app\nRUN pip install ai-fabric-device\nCOPY driver.py .\nCMD [\"python\", \"driver.py\"]\n</code></pre> <p>Build and push:</p> <pre><code># x86 (cloud / server)\ndocker build -t your-registry.example.com/fabric/temp-sensor:latest .\n\n# ARM64 (Raspberry Pi / edge)\ndocker build --platform linux/arm64 -t your-registry.example.com/fabric/temp-sensor:arm64 .\n\n# Push both\ndocker push your-registry.example.com/fabric/temp-sensor:latest\ndocker push your-registry.example.com/fabric/temp-sensor:arm64\n</code></pre> <p>Deploy on any new device \u2014 one command:</p> <pre><code>docker run -d \\\n  --name temp-sensor-001 \\\n  -e FABRIC_MESH_URL=nats://your-server:4222 \\\n  -e DEVICE_ID=temp-sensor-001 \\\n  -v /path/to/credentials/device.creds.json:/app/credentials/device.creds.json:ro \\\n  --restart unless-stopped \\\n  your-registry.example.com/fabric/temp-sensor:latest\n</code></pre> <p>The device connects to the Fabric mesh, self-registers, and starts accepting RPC calls immediately.</p>"},{"location":"device-connectivity/#provisioning-multiple-devices","title":"Provisioning Multiple Devices","text":"<p>Use docker-compose to bring up an entire fleet of devices at boot:</p> <pre><code># docker-compose.yaml\nservices:\n  temp-sensor-001:\n    image: your-registry.example.com/fabric/temp-sensor:latest\n    environment:\n      - FABRIC_MESH_URL=nats://your-server:4222\n      - DEVICE_ID=temp-sensor-001\n    volumes:\n      - ./credentials/temp-sensor-001.creds.json:/app/credentials/device.creds.json:ro\n    restart: unless-stopped\n\n  camera-001:\n    image: your-registry.example.com/fabric/camera:latest\n    environment:\n      - FABRIC_MESH_URL=nats://your-server:4222\n      - DEVICE_ID=camera-001\n    volumes:\n      - ./credentials/camera-001.creds.json:/app/credentials/device.creds.json:ro\n    restart: unless-stopped\n</code></pre> <pre><code>docker compose up -d\n</code></pre> <p>Add a device by adding a service to the compose file and redeploying. Remove a device by removing its service. The Fabric mesh tracks what's online.</p>"},{"location":"device-connectivity/#raspberry-pi","title":"Raspberry Pi","text":"<p>Docker runs natively on Raspberry Pi OS (64-bit). A new Pi goes from unboxed to connected in three steps:</p> <p>1. Install Docker:</p> <pre><code>curl -fsSL https://get.docker.com | sh\nsudo usermod -aG docker $USER\n</code></pre> <p>2. Pull the pre-built ARM image:</p> <pre><code>docker pull your-registry.example.com/fabric/temp-sensor:arm64\n</code></pre> <p>3. Run:</p> <pre><code>docker run -d \\\n  --name temp-sensor-001 \\\n  -e FABRIC_MESH_URL=nats://your-server:4222 \\\n  -e DEVICE_ID=temp-sensor-001 \\\n  -v /path/to/credentials/device.creds.json:/app/credentials/device.creds.json:ro \\\n  --restart unless-stopped \\\n  your-registry.example.com/fabric/temp-sensor:arm64\n</code></pre> <p><code>--restart unless-stopped</code> ensures the device driver survives reboots. The Pi connects to the Fabric mesh on every boot automatically.</p> <p>Bare Metal</p> <p>If you can't run Docker (resource-constrained microcontrollers, custom Linux builds), install <code>ai-fabric-device</code> directly with pip and run as a systemd service:</p> <pre><code>python3 -m venv ~/fabric-device\nsource ~/fabric-device/bin/activate\npip install ai-fabric-device\n</code></pre> <pre><code># /etc/systemd/system/fabric-device.service\n[Unit]\nDescription=AI Fabric Device Driver\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nType=simple\nUser=pi\nWorkingDirectory=/home/pi/fabric-device/app\nExecStart=/home/pi/fabric-device/bin/python driver.py\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <pre><code>sudo systemctl enable fabric-device\nsudo systemctl start fabric-device\n</code></pre>"},{"location":"infrastructure-setup/","title":"Fabric Mesh Setup","text":"<p>You're the administrator. You need to stand up the Fabric mesh so that devices can register and agents can discover them.</p> <p>The infrastructure has three services:</p> Service What it does Port NATS Message routing between devices and agents (JWT auth, TLS) 4222 etcd Stores device registrations with TTL leases 2379 Device Registry Service Listens for device registrations, tracks heartbeats, publishes online/offline events 8080"},{"location":"infrastructure-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker and Docker Compose</li> <li><code>nsc</code> \u2014 the NATS CLI tool for JWT/NKey management (<code>brew install nsc</code> or <code>go install github.com/nats-io/nsc/v2@latest</code>)</li> <li><code>ai-fabric-core</code> installed (<code>pip install \"ai-fabric-core[security]\"</code>)</li> </ul>"},{"location":"infrastructure-setup/#start-the-services","title":"Start the Services","text":"<pre><code>docker compose up nats-jwt etcd device-registry-service -d\n</code></pre> <p>This starts:</p> <ul> <li>nats-jwt \u2014 NATS 2.10 with JWT authentication enabled, using a generated resolver config</li> <li>etcd \u2014 v3.5 key-value store for device registration persistence</li> <li>device-registry-service \u2014 Python service that bridges NATS and etcd</li> </ul>"},{"location":"infrastructure-setup/#verify-services-are-running","title":"Verify Services Are Running","text":"<pre><code>docker ps --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\"\n</code></pre> <pre><code>NAMES                    STATUS              PORTS\ndevice-registry-service  Up 5 minutes        0.0.0.0:8080-&gt;8080/tcp\nnats-jwt                 Up 5 minutes        0.0.0.0:4222-&gt;4222/tcp, 6222/tcp, 8222/tcp\netcd                     Up 5 minutes        0.0.0.0:2379-2380-&gt;2379-2380/tcp\n</code></pre>"},{"location":"infrastructure-setup/#jwt-authentication-setup","title":"JWT Authentication Setup","text":"<p>NATS uses JWT + NKey authentication. Every device and agent gets a signed JWT that defines what NATS subjects it can publish and subscribe to.</p>"},{"location":"infrastructure-setup/#one-time-setup","title":"One-Time Setup","text":"<p>Initialize the NSC operator, account, and signing keys:</p> <pre><code># Set up the NATS JWT infrastructure\n./setup_jwt_auth.sh dev\n\n# Generate credentials for all built-in roles\n./gen_creds.sh --all --force\n</code></pre> <p>This creates:</p> <pre><code>security_infra/\n\u251c\u2500\u2500 credentials/\n\u2502   \u251c\u2500\u2500 devctl.creds.json          # Admin CLI credentials\n\u2502   \u251c\u2500\u2500 orchestrator.creds.json    # Agent/orchestrator credentials\n\u2502   \u2514\u2500\u2500 registry.creds.json        # Registry service credentials\n\u251c\u2500\u2500 certs/\n\u2502   \u2514\u2500\u2500 ca-cert.pem                # TLS CA certificate (if TLS enabled)\n\u2514\u2500\u2500 nats-jwt-generated.conf        # Generated NATS server config\n</code></pre> <p>nats-jwt-generated.conf Must Be a File</p> <p>Docker mounts this file into the NATS container. If it doesn't exist when you first run <code>docker compose up</code>, Docker will auto-create it as a directory, which breaks the mount. Always run <code>setup_jwt_auth.sh</code> before starting Docker. If you see mount errors, remove the directory and regenerate:</p> <pre><code>rm -rf security_infra/nats-jwt-generated.conf\n./setup_jwt_auth.sh dev\n./gen_creds.sh --all --force\n</code></pre>"},{"location":"infrastructure-setup/#credential-file-format","title":"Credential File Format","text":"<p>Each <code>.creds.json</code> file contains everything a client needs to authenticate:</p> <pre><code>{\n  \"device_id\": \"devctl\",\n  \"auth_type\": \"jwt\",\n  \"tenant\": \"default\",\n  \"nats\": {\n    \"urls\": [\"nats://nats-jwt:4222\"],\n    \"jwt\": \"eyJ0eXAiOiJKV1Qi...\",\n    \"nkey_seed\": \"SUAE...\"\n  }\n}\n</code></pre> <p>The JWT encodes:</p> <ul> <li>Which NATS subjects this client can publish to</li> <li>Which subjects it can subscribe to</li> <li>Expiry time (default: 90 days)</li> <li>Account and user identity</li> </ul>"},{"location":"infrastructure-setup/#device-registry-service","title":"Device Registry Service","text":"<p>The registry service is a Python process that runs inside Docker. It:</p> <ol> <li>Subscribes to <code>fabric.{tenant}.registry</code> for device registration RPCs</li> <li>Subscribes to <code>fabric.{tenant}.discovery</code> for device discovery queries</li> <li>Subscribes to <code>fabric.{tenant}.*.heartbeat</code> for device heartbeats</li> <li>Stores device records in etcd with TTL leases</li> <li>Publishes <code>device/online</code> and <code>device/offline</code> events when devices join or leave</li> </ol>"},{"location":"infrastructure-setup/#configuration","title":"Configuration","text":"Environment Variable Description Default <code>TENANT</code> Single tenant namespace <code>default</code> <code>TENANTS</code> Comma-separated list for multi-tenant \u2014 <code>NATS_CREDENTIALS_FILE</code> Path to registry <code>.creds.json</code> \u2014 <code>NATS_URLS</code> NATS server URLs <code>nats://nats-jwt:4222</code> <code>ETCD_HOST</code> etcd hostname <code>etcd</code> <code>ETCD_PORT</code> etcd port <code>2379</code>"},{"location":"infrastructure-setup/#what-gets-stored-in-etcd","title":"What Gets Stored in etcd","text":"<p>Each device registration creates a key at <code>/fabric/{tenant}/devices/{device_id}</code>:</p> <pre><code>{\n  \"device_id\": \"robot-001\",\n  \"device_type\": \"cleaning_robot\",\n  \"device_ttl\": 15,\n  \"capabilities\": {\n    \"functions\": [\n      {\n        \"name\": \"start_cleaning\",\n        \"description\": \"Start cleaning a zone.\",\n        \"parameters\": { \"type\": \"object\", \"properties\": { \"zone\": { \"type\": \"string\" } } }\n      }\n    ],\n    \"events\": [\n      { \"name\": \"cleaning_complete\", \"description\": \"Cleaning finished.\" }\n    ]\n  },\n  \"identity\": {\n    \"device_type\": \"cleaning_robot\",\n    \"manufacturer\": \"RoboCorp\",\n    \"model\": \"CleanBot-3000\",\n    \"firmware_version\": \"4.2.1\"\n  },\n  \"status\": {\n    \"location\": \"warehouse-B\",\n    \"availability\": \"available\"\n  },\n  \"registry\": {\n    \"device_registration_id\": \"a1b2c3d4-...\",\n    \"registered_at\": \"2026-02-20T10:30:00Z\"\n  }\n}\n</code></pre> <p>The record has an etcd lease with TTL. If the device stops sending heartbeats, the lease expires and the registry publishes a <code>device/offline</code> event.</p>"},{"location":"infrastructure-setup/#nats-topic-structure","title":"NATS Topic Structure","text":"<p>All messaging follows this pattern:</p> <pre><code>fabric.{tenant}.{device_id}.cmd              \u2190 RPC calls to a device\nfabric.{tenant}.{device_id}.event.{name}     \u2190 Events from a device\nfabric.{tenant}.{device_id}.heartbeat        \u2190 Device heartbeats\nfabric.{tenant}.registry                     \u2190 Device registration RPCs\nfabric.{tenant}.discovery                    \u2190 Device discovery queries\nfabric.{tenant}.device.online                \u2190 Registry: device came online\nfabric.{tenant}.device.offline               \u2190 Registry: device went offline\n</code></pre>"},{"location":"infrastructure-setup/#device-commissioning","title":"Device Commissioning","text":"<p>New devices need credentials before they can join the mesh. The commissioning flow is:</p>"},{"location":"infrastructure-setup/#1-factory-provisioning","title":"1. Factory Provisioning","text":"<p>Generate a device identity with a factory PIN:</p> <pre><code>python provision_device.py \\\n  --device-id robot-001 \\\n  --device-type cleaning_robot \\\n  --capabilities start_cleaning,stop_cleaning,get_battery_level\n</code></pre> <p>This produces a <code>robot-001.identity.json</code> that gets burned onto the device. It contains:</p> <ul> <li>Device ID and type</li> <li>Ed25519 NKey keypair (public key + seed)</li> <li>8-digit factory PIN (bcrypt-hashed)</li> <li><code>commissioned: false</code></li> </ul>"},{"location":"infrastructure-setup/#2-commission-the-device","title":"2. Commission the Device","text":"<p>The device boots, reads its identity file, sees <code>commissioned: false</code>, and starts an HTTP commissioning server on port 5540.</p> <p>From your admin workstation:</p> Auto-discover via mDNSSpecify device IP <pre><code># Find uncommissioned devices on the local network\ndevctl discover --timeout 5\n\n# Commission with PIN (device found via mDNS)\ndevctl commission robot-001 --pin 12345678\n</code></pre> <pre><code>devctl commission robot-001 \\\n  --pin 12345678 \\\n  --device-ip 192.168.1.50\n</code></pre> <p>What happens:</p> <ol> <li><code>devctl</code> contacts the device at <code>http://{ip}:5540/info</code> to get its NKey public key</li> <li>Generates a JWT signed for this device</li> <li>POSTs the JWT + credentials to <code>http://{ip}:5540/commission</code> with the PIN</li> <li>Device validates the PIN (bcrypt, 3 attempts max, 1-hour lockout)</li> <li>Device saves credentials to disk (<code>~/.fabric/credentials/robot-001.creds.json</code>)</li> <li>Device connects to NATS and self-registers</li> </ol>"},{"location":"infrastructure-setup/#3-verify","title":"3. Verify","text":"<pre><code>devctl list\n</code></pre> <p>The device should appear in the registry.</p>"},{"location":"infrastructure-setup/#admin-cli-devctl","title":"Admin CLI \u2014 devctl","text":"<p><code>devctl</code> is the admin command-line tool for managing the Fabric mesh. Installed with <code>ai-fabric-core</code>.</p>"},{"location":"infrastructure-setup/#list-devices","title":"List Devices","text":"<pre><code># Full output\ndevctl list\n\n# Compact \u2014 one line per device with functions and events\ndevctl list --compact\n</code></pre>"},{"location":"infrastructure-setup/#discover-uncommissioned-devices","title":"Discover Uncommissioned Devices","text":"<pre><code>devctl discover --timeout 10\n</code></pre> <p>Scans the local network via mDNS for devices running commissioning servers.</p> <p>Requires ai-fabric-core[security]</p> <p>Discovery and commissioning require the security extras: <code>pip install \"ai-fabric-core[security]\"</code></p>"},{"location":"infrastructure-setup/#commission-a-device","title":"Commission a Device","text":"<pre><code>devctl commission &lt;device_id&gt; --pin &lt;pin&gt; [--device-ip &lt;ip&gt;]\n</code></pre>"},{"location":"infrastructure-setup/#register-a-test-device","title":"Register a Test Device","text":"<p>For testing without real hardware:</p> <pre><code># Register and immediately exit\ndevctl register --id test-device-001\n\n# Register and keep alive (sends heartbeats)\ndevctl register --id test-device-001 --keepalive\n</code></pre>"},{"location":"infrastructure-setup/#interactive-repl","title":"Interactive REPL","text":"<pre><code>devctl interactive\n</code></pre> <p>Opens an interactive session for calling device functions, listing devices, and debugging the mesh.</p>"},{"location":"infrastructure-setup/#configuration_1","title":"Configuration","text":"<p><code>devctl</code> reads from environment variables:</p> Variable Description Default <code>NATS_URL</code> NATS server URL <code>nats://localhost:4222</code> <code>NATS_CREDENTIALS_FILE</code> Admin credentials file auto-discover <code>TENANT</code> Namespace <code>default</code> <code>DEVICE_TTL</code> Heartbeat timeout (seconds) <code>15</code>"},{"location":"infrastructure-setup/#multi-tenancy","title":"Multi-Tenancy","text":"<p>The mesh supports multiple tenants. Each tenant is a separate namespace \u2014 devices in one tenant are invisible to another.</p> <pre><code># Registry service handles multiple tenants\nTENANTS=warehouse,factory,lab docker compose up device-registry-service -d\n</code></pre> <p>NATS subject scoping ensures isolation:</p> <ul> <li>Warehouse agent credentials: can only access <code>fabric.warehouse.*</code></li> <li>Factory agent credentials: can only access <code>fabric.factory.*</code></li> </ul> <p>Tenant scoping is enforced at the NATS JWT level. Even if an agent knows a device ID in another tenant, the NATS server will deny the message.</p>"},{"location":"infrastructure-setup/#monitoring","title":"Monitoring","text":""},{"location":"infrastructure-setup/#nats-monitoring","title":"NATS Monitoring","text":"<p>NATS exposes an HTTP monitoring endpoint on port 8222:</p> <pre><code># Server info\ncurl http://localhost:8222/varz\n\n# Active connections\ncurl http://localhost:8222/connz\n\n# Active subscriptions\ncurl http://localhost:8222/subsz\n</code></pre>"},{"location":"infrastructure-setup/#etcd-check-device-registrations","title":"etcd \u2014 Check Device Registrations","text":"<pre><code># List all devices in default tenant\netcdctl get /fabric/default/devices/ --prefix --print-value-only | python -m json.tool\n\n# Watch for registration changes\netcdctl watch /fabric/default/devices/ --prefix\n</code></pre>"},{"location":"infrastructure-setup/#device-onlineoffline-events","title":"Device Online/Offline Events","text":"<p>Subscribe to registry lifecycle events:</p> <pre><code># Using nats CLI\nnats sub \"fabric.default.device.&gt;\"\n</code></pre> <p>You'll see <code>device/online</code> when a device registers and <code>device/offline</code> when its heartbeat lease expires.</p>"},{"location":"infrastructure-setup/#security-checklist","title":"Security Checklist","text":"<p>Before going to production:</p> <ul> <li>[ ] TLS enabled on NATS (<code>tls://</code> URLs, CA certificates distributed)</li> <li>[ ] Credential files have <code>0600</code> permissions (owner read/write only)</li> <li>[ ] NSC keys backed up and stored securely</li> <li>[ ] JWT expiry set to a reasonable window (not indefinite)</li> <li>[ ] Each device has unique credentials (no shared JWTs)</li> <li>[ ] <code>allow_insecure=False</code> on all production devices</li> <li>[ ] Multi-tenant scoping if running multiple fleets</li> <li>[ ] etcd authentication enabled</li> <li>[ ] Commissioning PINs are single-use and randomly generated</li> </ul>"},{"location":"native-agent/","title":"Fabric Native Agent","text":"<p>The Fabric Native Agent is a standalone CLI tool that runs as a long-lived daemon on your infrastructure. It connects to the Fabric mesh, discovers devices automatically, evaluates deterministic rules, and uses an LLM for open-ended reasoning \u2014 all configured through CLI flags and a YAML config file.</p> <p>Install it anywhere. Point it at your Fabric mesh. It handles the rest.</p>"},{"location":"native-agent/#installation","title":"Installation","text":"<pre><code>pip install ai-fabric-agent\n</code></pre> <p>This gives you the <code>ai-fabric-agent</code> command.</p>"},{"location":"native-agent/#quick-start","title":"Quick Start","text":"<pre><code># Minimal \u2014 connect to local Fabric mesh, use Bedrock Claude, discover all devices\nai-fabric-agent --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n\n# Full setup \u2014 rules, caching, filtered discovery, goal\nai-fabric-agent \\\n  --nats-url nats://your-server:4222 \\\n  --credentials /path/to/agent.creds.json \\\n  --model-provider bedrock \\\n  --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0 \\\n  --rules rules.yaml \\\n  --enable-caching \\\n  --goal \"Keep the warehouse temperature between 18\u00b0C and 24\u00b0C\"\n</code></pre> <p>The agent starts, connects to the Fabric mesh, discovers devices, loads rules, and begins its event loop. It runs continuously until you stop it.</p>"},{"location":"native-agent/#cli-reference","title":"CLI Reference","text":"<pre><code>ai-fabric-agent [OPTIONS]\n</code></pre>"},{"location":"native-agent/#connection","title":"Connection","text":"Flag Env Variable Description Default <code>--nats-url</code> <code>NATS_URL</code> Fabric mesh URL <code>nats://localhost:4222</code> <code>--credentials</code> <code>NATS_CREDENTIALS_FILE</code> Path to <code>.creds.json</code> Auto-discovery <code>--zone</code> <code>TENANT</code> Fabric tenant/namespace <code>default</code> <code>--tls-ca</code> <code>NATS_TLS_CA_FILE</code> CA certificate for TLS Auto-discovery"},{"location":"native-agent/#model-selection","title":"Model Selection","text":"Flag Env Variable Description Default <code>--model-provider</code> <code>FABRIC_MODEL_PROVIDER</code> <code>bedrock</code> or <code>arm-registry</code> required <code>--model-id</code> <code>FABRIC_MODEL_ID</code> Model identifier (provider-specific) required <code>--model-region</code> <code>AWS_REGION</code> AWS region (Bedrock only) <code>us-east-1</code> <code>--local-model-checkpoint</code> \u2014 Path to local model checkpoint (Arm registry) \u2014 <code>--quantization</code> \u2014 Quantization level: <code>fp16</code>, <code>int8</code>, <code>int4</code> (Arm registry) <code>fp16</code> <code>--fallback-provider</code> \u2014 Fallback model provider if primary is unavailable \u2014 <code>--fallback-model-id</code> \u2014 Fallback model identifier \u2014"},{"location":"native-agent/#discovery","title":"Discovery","text":"Flag Env Variable Description Default <code>--discover-all</code> \u2014 Discover all device types <code>true</code> <code>--device-types</code> \u2014 Comma-separated list of device types to discover All <code>--refresh-interval</code> \u2014 Seconds between registry syncs <code>30</code> <code>--no-watch</code> \u2014 Disable real-time device join/leave events \u2014"},{"location":"native-agent/#rules","title":"Rules","text":"Flag Description Default <code>--rules</code> Path to rules YAML file \u2014 (no rules) <code>--rules-dir</code> Path to directory of rule YAML files \u2014 <code>--dry-run-rules</code> Validate rules without starting the agent \u2014"},{"location":"native-agent/#caching","title":"Caching","text":"Flag Env Variable Description Default <code>--enable-caching</code> \u2014 Enable Redis LLM response caching Disabled <code>--redis-url</code> <code>REDIS_URL</code> Redis connection URL <code>redis://localhost:6379</code> <code>--cache-ttl</code> \u2014 Cache entry TTL in seconds <code>3600</code> <code>--managed-redis</code> \u2014 Let the agent start/stop its own Redis instance \u2014"},{"location":"native-agent/#agent-behavior","title":"Agent Behavior","text":"Flag Description Default <code>--goal</code> High-level goal for the agent to pursue \u2014 (event-driven only) <code>--system-prompt</code> Override the default system prompt Built-in <code>--config</code> Path to YAML config file (replaces all flags) \u2014 <code>--log-level</code> Logging verbosity: <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> <code>info</code> <code>--log-file</code> Write logs to file instead of stderr stderr"},{"location":"native-agent/#configuration-file","title":"Configuration File","text":"<p>Every CLI flag can also be set in a YAML config file. Pass it with <code>--config</code>:</p> <pre><code>ai-fabric-agent --config agent.yaml\n</code></pre> <pre><code># agent.yaml\n\nconnection:\n  nats_url: nats://your-server:4222\n  credentials: /path/to/agent.creds.json\n  zone: default\n\nmodel:\n  provider: bedrock\n  model_id: us.anthropic.claude-sonnet-4-5-20250929-v1:0\n  region: us-east-1\n  fallback:\n    provider: arm-registry\n    model_id: arm/llama3-8b-chat-optimized\n\ndiscovery:\n  device_types:\n    - cleaning_robot\n    - temperature_sensor\n    - security_camera\n  refresh_interval: 30\n  watch_events: true\n\nrules: rules.yaml              # or inline rules (see below)\n\ncache:\n  enabled: true\n  redis_url: redis://localhost:6379\n  ttl: 3600\n  managed: false\n\ngoal: \"Keep the warehouse temperature between 18\u00b0C and 24\u00b0C\"\nlog_level: info\n</code></pre> <p>CLI flags override config file values. Environment variables sit in between \u2014 config file &lt; env var &lt; CLI flag.</p>"},{"location":"native-agent/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  ai-fabric-agent (long-lived daemon)                        \u2502\n\u2502                                                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Device       \u2502  \u2502  Rule        \u2502  \u2502  Goal            \u2502  \u2502\n\u2502  \u2502  Discovery    \u2502  \u2502  Engine      \u2502  \u2502  Inference       \u2502  \u2502\n\u2502  \u2502  (automatic)  \u2502  \u2502  (no LLM)   \u2502  \u2502  (from caps)     \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502         \u2502                 \u2502                    \u2502             \u2502\n\u2502         \u25bc                 \u25bc                    \u25bc             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502  Agent Core                                         \u2502    \u2502\n\u2502  \u2502  Model: Bedrock / Arm Registry                      \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                         \u2502                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502  Redis Cache (optional)                              \u2502    \u2502\n\u2502  \u2502  LLM response caching \u2014 reduces latency and cost     \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502 JSON-RPC over NATS\n                          \u25bc\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                 \u2502  Fabric Mesh    \u2502\n                 \u2502  (NATS + JWT)   \u2502\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u25bc            \u25bc            \u25bc\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502robot   \u2502   \u2502camera  \u2502   \u2502sensor  \u2502\n      \u2502-001    \u2502   \u2502-002    \u2502   \u2502-003    \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"native-agent/#inbuilt-device-discovery","title":"Inbuilt Device Discovery","text":"<p>The agent subscribes to the Fabric device registry and maintains a live device table. When devices come online, go offline, or update their capabilities, the agent's view updates automatically. You don't call <code>discover_devices</code> \u2014 the agent already knows what's available.</p> <pre><code># Discover everything\nai-fabric-agent --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n\n# Only discover specific device types\nai-fabric-agent --device-types cleaning_robot,temperature_sensor \\\n  --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n\n# Faster refresh cycle for latency-sensitive environments\nai-fabric-agent --refresh-interval 5 \\\n  --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n</code></pre> <p>The agent uses discovered device capabilities to build its tool set dynamically. If a new device type appears on the mesh, the agent can use it immediately \u2014 no restart needed.</p>"},{"location":"native-agent/#deterministic-event-rules","title":"Deterministic Event Rules","text":"<p>Not every decision needs an LLM. For known cause-and-effect patterns, define rules that execute instantly and deterministically.</p>"},{"location":"native-agent/#rules-file","title":"Rules File","text":"<pre><code># rules.yaml\n\nrules:\n  - name: high-temperature-response\n    description: \"Activate cooling when temperature exceeds threshold\"\n    trigger:\n      event: threshold_alert\n      device_type: temperature_sensor\n      condition:\n        temperature_c: { gte: 80 }\n    action:\n      invoke:\n        device_type: cooling_system\n        function: activate\n        params:\n          mode: emergency\n\n  - name: motion-detected-lights\n    description: \"Turn on lights when motion is detected after hours\"\n    trigger:\n      event: motion_detected\n      device_type: security_camera\n      condition:\n        time_of_day: { after: \"18:00\", before: \"06:00\" }\n    action:\n      invoke:\n        device_type: smart_light\n        function: turn_on\n        params:\n          brightness: 100\n\n  - name: battery-low-alert\n    description: \"Log alert when any robot battery drops below 15%\"\n    trigger:\n      event: battery_low\n      device_type: \"*\"          # match any device type\n      condition:\n        battery_pct: { lt: 15 }\n    action:\n      log:\n        level: warn\n        message: \"Low battery on {device_id}: {battery_pct}%\"\n</code></pre>"},{"location":"native-agent/#using-rules-from-the-cli","title":"Using Rules from the CLI","text":"<pre><code># Load a single rules file\nai-fabric-agent --rules rules.yaml \\\n  --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n\n# Load all YAML files from a directory\nai-fabric-agent --rules-dir /etc/fabric/rules/ \\\n  --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n\n# Validate rules without starting the agent\nai-fabric-agent --rules rules.yaml --dry-run-rules\n</code></pre> <p>Rules are evaluated before the LLM sees the event. If a rule matches, the action fires immediately. If no rule matches, the event is passed to the LLM for reasoning.</p> <p>This gives you:</p> <ul> <li>Predictable behavior for known scenarios \u2014 no variance between runs</li> <li>Low latency \u2014 rule evaluation is sub-millisecond</li> <li>Zero token cost for deterministic actions</li> <li>Auditability \u2014 rules are version-controlled YAML, not emergent model behavior</li> </ul>"},{"location":"native-agent/#amazon-bedrock-model-access","title":"Amazon Bedrock Model Access","text":"<p>Use any model available on Amazon Bedrock. AWS credentials resolve from the standard chain (environment, IAM role, config file).</p> <pre><code># Claude on Bedrock\nai-fabric-agent \\\n  --model-provider bedrock \\\n  --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0 \\\n  --model-region us-east-1\n\n# Llama on Bedrock\nai-fabric-agent \\\n  --model-provider bedrock \\\n  --model-id meta.llama3-1-70b-instruct-v1:0 \\\n  --model-region us-west-2\n\n# Mistral on Bedrock\nai-fabric-agent \\\n  --model-provider bedrock \\\n  --model-id mistral.mistral-large-2407-v1:0 \\\n  --model-region eu-west-1\n</code></pre> <p>Switch models without changing any agent logic, rules, or configuration. Tools, prompts, and device interactions work the same regardless of which model is behind the reasoning.</p>"},{"location":"native-agent/#arm-model-registry","title":"Arm Model Registry","text":"<p>For edge deployments where latency or connectivity makes cloud models impractical, select a model from the Arm model registry. These models are optimized for inference on Arm-based hardware \u2014 Cortex-A, Neoverse, or Ethos-U processors.</p> <pre><code># Run a local Arm-optimized model\nai-fabric-agent \\\n  --model-provider arm-registry \\\n  --model-id arm/llama3-8b-chat-optimized \\\n  --quantization int8\n\n# Use a local checkpoint file\nai-fabric-agent \\\n  --model-provider arm-registry \\\n  --local-model-checkpoint /opt/models/llama3-8b-arm.bin \\\n  --quantization int4\n</code></pre> <p>This is useful when:</p> <ul> <li>Devices are in air-gapped environments with no cloud access</li> <li>Round-trip latency to a cloud model is too high for real-time control</li> <li>You want to keep data on-premises for compliance</li> </ul>"},{"location":"native-agent/#model-fallback","title":"Model Fallback","text":"<p>Configure a primary and fallback model. If the primary is unavailable (local model fails to load, Bedrock returns 5xx), the agent falls back automatically.</p> <pre><code># Primary: local Arm model. Fallback: Bedrock Claude.\nai-fabric-agent \\\n  --model-provider arm-registry \\\n  --model-id arm/llama3-8b-chat-optimized \\\n  --fallback-provider bedrock \\\n  --fallback-model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n</code></pre>"},{"location":"native-agent/#redis-response-cache","title":"Redis Response Cache","text":"<p>Enable caching to store LLM responses in Redis. Identical or semantically similar queries hit the cache instead of the model, reducing latency and cost.</p> <pre><code># Enable caching with an existing Redis instance\nai-fabric-agent \\\n  --enable-caching \\\n  --redis-url redis://your-redis:6379 \\\n  --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n\n# Let the agent manage its own Redis instance\nai-fabric-agent \\\n  --enable-caching \\\n  --managed-redis \\\n  --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n\n# Custom TTL (seconds)\nai-fabric-agent \\\n  --enable-caching \\\n  --cache-ttl 7200 \\\n  --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n</code></pre>"},{"location":"native-agent/#what-gets-cached","title":"What Gets Cached","text":"<ul> <li>Device queries \u2014 \"What's the temperature in zone A?\" returns a cached response if the same query was answered recently</li> <li>Planning responses \u2014 complex multi-step plans are cached to avoid regenerating them for identical situations</li> <li>Tool call sequences \u2014 when the same reasoning leads to the same tool calls, skip the model entirely</li> </ul>"},{"location":"native-agent/#cache-invalidation","title":"Cache Invalidation","text":"<p>The cache automatically invalidates entries when:</p> <ul> <li>The device landscape changes (new device, device goes offline)</li> <li>A rule is added or modified</li> <li>The TTL expires</li> <li>You manually flush it via the agent API</li> </ul>"},{"location":"native-agent/#goal-inference-from-device-capabilities","title":"Goal Inference from Device Capabilities","text":"<p>When you provide a <code>--goal</code>, the agent doesn't just list devices \u2014 it reasons about what's possible given the devices that are online.</p> <pre><code>ai-fabric-agent \\\n  --goal \"Keep the warehouse temperature between 18\u00b0C and 24\u00b0C\" \\\n  --model-provider bedrock --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n</code></pre> <p>The agent will:</p> <ol> <li>Check discovered devices for temperature-related capabilities (<code>get_reading</code>, <code>threshold_alert</code>)</li> <li>Check for actuation capabilities (<code>activate</code> on cooling systems, <code>set_temperature</code> on HVAC)</li> <li>Set up monitoring using available sensor events</li> <li>Create a control loop using available actuator functions</li> <li>Fall back to alerting a human if no actuator is available</li> </ol> <p>If you add a new HVAC device to the mesh later, the agent picks it up through discovery and incorporates it into the plan \u2014 no restart needed.</p>"},{"location":"native-agent/#capability-matching","title":"Capability Matching","text":"<p>The agent maps high-level goals to device capabilities using the function names, descriptions, and parameter schemas that devices expose through <code>@rpc()</code> decorators:</p> <pre><code>Goal: \"Keep the warehouse safe\"\n  \u251c\u2500\u2500 security_camera \u2192 watch_feed(), detect_anomaly()\n  \u251c\u2500\u2500 door_lock \u2192 lock(), unlock(), get_status()\n  \u251c\u2500\u2500 motion_sensor \u2192 motion_detected (event)\n  \u2514\u2500\u2500 alarm_system \u2192 trigger_alarm(), silence_alarm()\n</code></pre> <p>If a required capability is missing (no alarm system on the mesh), the agent reports what it can and cannot do \u2014 rather than silently ignoring part of the goal.</p>"},{"location":"native-agent/#examples","title":"Examples","text":""},{"location":"native-agent/#minimal-daemon","title":"Minimal Daemon","text":"<pre><code>ai-fabric-agent \\\n  --model-provider bedrock \\\n  --model-id us.anthropic.claude-sonnet-4-5-20250929-v1:0\n</code></pre> <p>Connects to the local Fabric mesh, discovers all devices, runs in event-driven mode. No rules, no caching, no goal \u2014 the agent responds to events using LLM reasoning.</p>"},{"location":"native-agent/#production-deployment","title":"Production Deployment","text":"<pre><code>ai-fabric-agent \\\n  --config /etc/fabric/agent.yaml \\\n  --log-file /var/log/fabric-agent.log \\\n  --log-level info\n</code></pre> <pre><code># /etc/fabric/agent.yaml\nconnection:\n  nats_url: nats://nats.internal:4222\n  credentials: /etc/fabric/agent.creds.json\n  zone: warehouse-east\n\nmodel:\n  provider: bedrock\n  model_id: us.anthropic.claude-sonnet-4-5-20250929-v1:0\n  region: us-east-1\n\ndiscovery:\n  device_types:\n    - cleaning_robot\n    - temperature_sensor\n    - security_camera\n    - cooling_system\n    - smart_light\n  refresh_interval: 15\n\nrules: /etc/fabric/rules/\n\ncache:\n  enabled: true\n  redis_url: redis://redis.internal:6379\n  ttl: 1800\n\ngoal: \"Monitor warehouse conditions and respond to anomalies\"\n</code></pre>"},{"location":"native-agent/#edge-deployment-air-gapped","title":"Edge Deployment (Air-Gapped)","text":"<pre><code>ai-fabric-agent \\\n  --nats-url nats://192.168.1.10:4222 \\\n  --model-provider arm-registry \\\n  --local-model-checkpoint /opt/models/llama3-8b-arm.bin \\\n  --quantization int8 \\\n  --rules /opt/fabric/rules.yaml \\\n  --goal \"Monitor and control factory floor equipment\"\n</code></pre> <p>No cloud access needed. Model runs locally on the edge device. Rules handle known scenarios deterministically. The LLM handles the rest.</p>"},{"location":"native-agent/#rules-only-mode-no-llm","title":"Rules-Only Mode (No LLM)","text":"<pre><code>ai-fabric-agent \\\n  --rules rules.yaml \\\n  --model-provider none \\\n  --log-level debug\n</code></pre> <p>Run purely deterministic \u2014 no model, no token cost. Events that don't match a rule are logged but not acted on.</p>"},{"location":"strands-integration/","title":"Strands Integration","text":"<p>Give your Strands agent the ability to discover and control physical devices \u2014 robots, cameras, sensors, industrial controllers \u2014 over a NATS messaging mesh.</p> <p>Your devices are already on the network, exposing typed functions. The <code>ai-fabric-tools</code> SDK lets your agent see them and call them.</p>"},{"location":"strands-integration/#what-you-get","title":"What You Get","text":"<ul> <li><code>discover_devices</code> \u2014 see every device on the mesh, its functions, parameter schemas, and current status</li> <li><code>invoke_device</code> \u2014 call any function on any device by name and get the result back</li> <li><code>invoke_device_with_fallback</code> \u2014 try a list of devices in order until one succeeds</li> <li><code>get_device_status</code> \u2014 check a specific device before acting on it</li> </ul> <p>These are standard Strands tools. They show up in your agent's tool list alongside anything else you provide. The agent decides when to use them as part of its normal reasoning.</p>"},{"location":"strands-integration/#installation","title":"Installation","text":"<pre><code>pip install ai-fabric-tools[strands]\n</code></pre>"},{"location":"strands-integration/#prerequisites","title":"Prerequisites","text":"<p>You need:</p> <ol> <li>A running NATS server with devices connected (your Fabric mesh)</li> <li>A credentials file (<code>.creds.json</code>) that grants your agent access to the devices it needs</li> <li>An <code>ANTHROPIC_API_KEY</code> for your Strands agent</li> </ol>"},{"location":"strands-integration/#connect-and-go","title":"Connect and Go","text":"<pre><code>from ai_fabric_tools import connect\nfrom ai_fabric_tools.adapters.strands import discover_devices, invoke_device\nfrom strands import Agent\nfrom strands.models.anthropic import AnthropicModel\n\nconnect(\n    nats_url=\"nats://your-server:4222\",\n    credentials=\"/path/to/agent.creds.json\",\n)\n\nagent = Agent(\n    model=AnthropicModel(model_id=\"us.anthropic.claude-sonnet-4-5-20250929-v1:0\"),\n    tools=[discover_devices, invoke_device],\n    system_prompt=\"You are an assistant that monitors and controls IoT devices.\",\n)\n\nagent(\"What devices are online? Check the battery level of any robots you find.\")\n</code></pre> <p>The agent will call <code>discover_devices</code> to see what's available, then call <code>invoke_device</code> to check battery levels. You didn't write that logic \u2014 the model figured it out from the tool descriptions and the device function schemas.</p>"},{"location":"strands-integration/#connection-options","title":"Connection Options","text":"<p>You can configure the connection explicitly or through environment variables:</p> Environment VariablesExplicit <pre><code>export NATS_URL=nats://your-server:4222\nexport NATS_CREDENTIALS_FILE=/path/to/agent.creds.json\nexport TENANT=default\n</code></pre> <pre><code>from ai_fabric_tools import connect\nconnect()  # picks up env vars automatically\n</code></pre> <pre><code>from ai_fabric_tools import connect\nconnect(\n    nats_url=\"nats://your-server:4222\",\n    credentials=\"/path/to/agent.creds.json\",\n    zone=\"warehouse-east\",\n)\n</code></pre> <p>The connection is lazy \u2014 it opens on the first tool call, not at import time.</p>"},{"location":"strands-integration/#tool-reference","title":"Tool Reference","text":""},{"location":"strands-integration/#discover_devices","title":"discover_devices","text":"<p>See what's on the network.</p> <pre><code>from ai_fabric_tools.adapters.strands import discover_devices\n</code></pre> Parameter Type Description Default <code>device_type</code> <code>str \\| None</code> Filter by type, e.g. <code>\"robot\"</code>, <code>\"camera\"</code> (fuzzy match) <code>None</code> (all) <code>refresh</code> <code>bool</code> Bypass cache and query registry directly <code>False</code> <p>Example response:</p> <pre><code>[\n    {\n        \"device_id\": \"robot-001\",\n        \"device_type\": \"cleaning_robot\",\n        \"location\": \"warehouse-B\",\n        \"status\": {\"availability\": \"available\"},\n        \"functions\": [\n            {\n                \"name\": \"start_cleaning\",\n                \"description\": \"Start cleaning a specified zone.\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"zone\": {\"type\": \"string\", \"description\": \"Target zone ID\"}\n                    }\n                }\n            },\n            {\n                \"name\": \"get_battery_level\",\n                \"description\": \"Returns current battery percentage.\",\n                \"parameters\": {}\n            }\n        ],\n        \"events\": [\"cleaning_complete\", \"battery_low\"]\n    },\n    {\n        \"device_id\": \"camera-002\",\n        \"device_type\": \"vision_camera\",\n        \"location\": \"entrance\",\n        \"status\": {\"availability\": \"available\"},\n        \"functions\": [\n            {\n                \"name\": \"capture_image\",\n                \"description\": \"Capture an image from the camera.\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"resolution\": {\"type\": \"string\", \"default\": \"1080p\"}\n                    }\n                }\n            }\n        ],\n        \"events\": [\"motion_detected\"]\n    }\n]\n</code></pre> <p>The model reads these function schemas and knows exactly what it can call and with what parameters. No manual tool definitions needed on your side.</p> <p>Inject Device Context into the System Prompt</p> <p>For faster first responses, discover devices at startup and put the result in the system prompt. The model starts the conversation already knowing what's available.</p> <pre><code>from ai_fabric_tools import connect, discover_devices as discover\n\nconnect()\ndevices = discover()\n\nagent = Agent(\n    tools=[discover_devices, invoke_device],\n    system_prompt=f\"You control IoT devices. Available devices:\\n\\n{devices}\",\n)\n</code></pre> <p>Or let the agent call <code>discover_devices</code> itself when it needs to \u2014 both patterns work.</p>"},{"location":"strands-integration/#invoke_device","title":"invoke_device","text":"<p>Call a function on a device.</p> <pre><code>from ai_fabric_tools.adapters.strands import invoke_device\n</code></pre> Parameter Type Description Default <code>device_id</code> <code>str</code> Target device, e.g. <code>\"robot-001\"</code> required <code>function</code> <code>str</code> Function to call, e.g. <code>\"start_cleaning\"</code> required <code>params</code> <code>dict \\| None</code> Function parameters <code>None</code> <code>llm_reasoning</code> <code>str \\| None</code> Why the agent is making this call \u2014 logged for observability <code>None</code> <p>Example responses:</p> <pre><code># Success\n{\"success\": True, \"result\": {\"zone\": \"B-7\", \"status\": \"cleaning_in_progress\"}}\n\n# Failure\n{\"success\": False, \"error\": \"Device robot-001 is offline\"}\n</code></pre> <p>The <code>llm_reasoning</code> field is not sent to the device. It's logged on the agent side so you can trace back why the model made a particular call.</p>"},{"location":"strands-integration/#invoke_device_with_fallback","title":"invoke_device_with_fallback","text":"<p>Same as <code>invoke_device</code>, but tries a list of devices in order. Useful when the agent identifies multiple candidates and wants automatic failover.</p> <pre><code>from ai_fabric_tools.adapters.strands import invoke_device_with_fallback\n</code></pre> Parameter Type Description Default <code>device_ids</code> <code>list[str]</code> Devices to try, in preference order required <code>function</code> <code>str</code> Function to call required <code>params</code> <code>dict \\| None</code> Function parameters <code>None</code> <code>llm_reasoning</code> <code>str \\| None</code> Decision rationale <code>None</code> <p>Example responses:</p> <pre><code># Second device succeeded\n{\"success\": True, \"device_id\": \"robot-002\", \"result\": {\"status\": \"cleaning\"}}\n\n# All failed\n{\n    \"success\": False,\n    \"error\": \"All devices failed\",\n    \"failed_devices\": [\n        {\"device_id\": \"robot-001\", \"error\": \"offline\"},\n        {\"device_id\": \"robot-002\", \"error\": \"timeout\"}\n    ]\n}\n</code></pre>"},{"location":"strands-integration/#get_device_status","title":"get_device_status","text":"<p>Check a single device's current state before acting on it.</p> <pre><code>from ai_fabric_tools.adapters.strands import get_device_status\n</code></pre> Parameter Type Description Default <code>device_id</code> <code>str</code> Device to query required <p>Example response:</p> <pre><code>{\n    \"device_id\": \"robot-001\",\n    \"device_type\": \"cleaning_robot\",\n    \"location\": \"warehouse-B\",\n    \"status\": {\"availability\": \"available\"},\n    \"functions\": [\"start_cleaning\", \"stop_cleaning\", \"get_battery_level\"]\n}\n</code></pre>"},{"location":"strands-integration/#example-agent-that-reacts-to-device-events","title":"Example: Agent That Reacts to Device Events","text":"<p>A complete working example. Devices emit events (sensor readings, alerts, status changes). The agent subscribes, batches them, and reasons about what to do.</p> <pre><code>import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\n\nfrom ai_fabric_tools import connect, get_connection\nfrom ai_fabric_tools import discover_devices as discover\nfrom ai_fabric_tools.adapters.strands import (\n    discover_devices,\n    invoke_device,\n    invoke_device_with_fallback,\n    get_device_status,\n)\nfrom strands import Agent\nfrom strands.models.anthropic import AnthropicModel\n\n\ndef build_prompt(events: list[dict]) -&gt; str:\n    lines = []\n    for e in events:\n        device_id = e.get(\"device_id\", \"?\")\n        event_name = e.get(\"event_name\", \"?\")\n        payload = {k: v for k, v in e.items()\n                   if k not in (\"device_id\", \"event_name\", \"event_id\", \"ts\")}\n        lines.append(f\"  {device_id}::{event_name} \u2192 {payload}\")\n\n    return (\n        f\"{len(events)} new device events:\\n\"\n        + \"\\n\".join(lines)\n        + \"\\n\\nAnalyze these events and take action if needed.\"\n    )\n\n\nasync def main():\n    connect()\n    conn = get_connection()\n\n    devices = discover()\n    agent = Agent(\n        model=AnthropicModel(model_id=\"us.anthropic.claude-sonnet-4-5-20250929-v1:0\"),\n        tools=[discover_devices, invoke_device, invoke_device_with_fallback, get_device_status],\n        system_prompt=f\"You monitor IoT devices. Available:\\n\\n{devices}\",\n    )\n\n    executor = ThreadPoolExecutor(max_workers=1)\n\n    async for batch in conn.subscribe_events(batch_window=12.0):\n        if not batch:\n            continue\n\n        prompt = build_prompt(batch)\n        print(f\"\\n--- {len(batch)} events received ---\")\n\n        loop = asyncio.get_running_loop()\n        response = await loop.run_in_executor(\n            executor, lambda p=prompt: str(agent(p))\n        )\n        print(f\"Agent: {response}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>What happens:</p> <ol> <li>Agent connects to the NATS mesh and discovers all devices</li> <li>Subscribes to every device event on the network</li> <li>Events accumulate over a 12-second window</li> <li>Each batch becomes a prompt: \"Here are 5 new events. Analyze and act.\"</li> <li>The agent reads the events, decides what to do, and calls <code>invoke_device</code> if action is needed</li> </ol> <p>Sync/Async Bridge</p> <p>Strands agents are synchronous. NATS event subscriptions are async. The <code>ThreadPoolExecutor</code> bridges the two \u2014 the agent runs in a worker thread while the event loop handles NATS I/O.</p>"},{"location":"strands-integration/#access-control","title":"Access Control","text":"<p>Credentials define what your agent can see and do. A credential scoped to <code>warehouse-east</code> devices will:</p> <ul> <li><code>discover_devices</code> \u2014 only returns warehouse-east devices</li> <li><code>invoke_device</code> \u2014 calls to out-of-scope devices return an authorization error, not a silent failure</li> <li><code>get_device_status</code> \u2014 same scoping</li> </ul> <p>This is enforced at the NATS layer, not in the SDK. The tools don't filter \u2014 the messaging infrastructure does.</p>"},{"location":"strands-integration/#how-it-works-under-the-hood","title":"How It Works Under the Hood","text":"<p>The Strands adapter is thin. Each tool is a plain Python function wrapped with <code>@strands.tool</code>:</p> <pre><code>from strands import tool as strands_tool\nfrom ai_fabric_tools.tools import discover_devices as _discover_devices\n\ndiscover_devices = strands_tool(_discover_devices)\n</code></pre> <p>The core functions use <code>nats-py</code> to send JSON-RPC requests over NATS subjects:</p> <ul> <li>Discovery: <code>fabric.{zone}.discovery</code> \u2192 registry responds with device list</li> <li>Invoke: <code>fabric.{zone}.{device_id}.cmd</code> \u2192 device executes function and responds</li> <li>Events: <code>fabric.{zone}.{device_id}.event.{event_name}</code> \u2192 device publishes, agent subscribes</li> </ul> <p>No HTTP, no REST, no WebSocket. Direct NATS pub/sub with request-reply for RPCs.</p>"},{"location":"strands-integration/#what-these-tools-dont-do","title":"What These Tools Don't Do","text":"<p>The tools are stateless primitives. They do not:</p> <ul> <li>Subscribe to events (use <code>conn.subscribe_events()</code> directly \u2014 see example above)</li> <li>Maintain conversation or device state between calls</li> <li>Batch multiple device calls into one request</li> <li>Run any reasoning or decision logic</li> </ul> <p>All orchestration lives in your agent. Fabric gives your agent reach into the physical world. Your agent decides what to do with it.</p>"}]}