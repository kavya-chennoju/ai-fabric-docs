{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AI Fabric","text":"<p>AI Fabric is a coordination layer for physical systems. Robots, cameras, sensors, and industrial controllers connect to a shared NATS mesh, expose typed functions and events, and become discoverable and controllable by AI agents \u2014 or by each other.</p> <p>There are three packages. Use the ones you need.</p>"},{"location":"#packages","title":"Packages","text":""},{"location":"#ai-fabric-device","title":"ai-fabric-device","text":"<p>The device SDK. Install this on your edge hardware \u2014 Raspberry Pi, robot, sensor, controller. Write a <code>DeviceDriver</code> subclass, decorate your methods, and the runtime handles NATS connection, registration, heartbeats, and command routing.</p> <pre><code>pip install ai-fabric-device\n</code></pre> <pre><code>from fabric_device import DeviceRuntime\nfrom fabric_device.drivers import DeviceDriver, rpc, emit\n\nclass TemperatureSensor(DeviceDriver):\n    device_type = \"temperature_sensor\"\n\n    @rpc()\n    async def get_reading(self) -&gt; dict:\n        \"\"\"Get current temperature and humidity.\"\"\"\n        return {\"temperature_c\": 22.5, \"humidity_pct\": 45}\n\n    @emit()\n    async def threshold_alert(self, temperature_c: float, severity: str):\n        \"\"\"Temperature exceeded a threshold.\"\"\"\n        pass\n</code></pre> <p>Device Connectivity Guide \u2192</p>"},{"location":"#ai-fabric-tools","title":"ai-fabric-tools","text":"<p>The agent SDK. Install this alongside your AI agent framework. Gives your agent four tool functions to discover devices and call their functions over the mesh.</p> <pre><code>pip install ai-fabric-tools[strands]\n</code></pre> <pre><code>from ai_fabric_tools import connect\nfrom ai_fabric_tools.adapters.strands import discover_devices, invoke_device\nfrom strands import Agent\n\nconnect()\nagent = Agent(tools=[discover_devices, invoke_device])\nagent(\"What devices are online? Check the battery on any robots.\")\n</code></pre> <p>Strands Integration Guide \u2192</p>"},{"location":"#ai-fabric-core","title":"ai-fabric-core","text":"<p>The server package. Extends <code>ai-fabric-device</code> with the device registry, security (commissioning, ACLs), distributed state (etcd), audit logging (MongoDB), and CLI tools (<code>devctl</code>, <code>statectl</code>). Install this on your server or admin workstation.</p> <pre><code>pip install \"ai-fabric-core[all]\"\n</code></pre>"},{"location":"#how-it-fits-together","title":"How It Fits Together","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Strands     \u2502       \u2502   Fabric     \u2502       \u2502   Devices    \u2502\n\u2502  Agent       \u2502       \u2502   Server     \u2502       \u2502              \u2502\n\u2502              \u2502       \u2502              \u2502       \u2502  robot-001   \u2502\n\u2502  ai-fabric-  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  NATS + JWT  \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2502  camera-002  \u2502\n\u2502  tools       \u2502 JSON- \u2502  Registry    \u2502 self- \u2502  sensor-003  \u2502\n\u2502              \u2502 RPC   \u2502  etcd        \u2502 reg.  \u2502              \u2502\n\u2502              \u2502       \u2502              \u2502       \u2502  ai-fabric-  \u2502\n\u2502              \u2502       \u2502  ai-fabric-  \u2502       \u2502  device      \u2502\n\u2502              \u2502       \u2502  core        \u2502       \u2502              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Devices run <code>ai-fabric-device</code>, connect to NATS, self-register, and expose <code>@rpc</code> functions and <code>@emit</code> events.</p> <p>Agents run <code>ai-fabric-tools</code>, discover devices on the mesh, and invoke their functions as part of the agent's normal reasoning loop.</p> <p>The server runs <code>ai-fabric-core</code> with NATS (messaging), etcd (state), and the device registry. It routes messages and tracks which devices are online.</p> <p>No component knows about the internals of the other. Devices don't know they're being called by an AI agent. Agents don't know what protocol the device uses internally. NATS handles the routing.</p>"},{"location":"device-connectivity/","title":"Device Connectivity to Fabric","text":"<p>You manufacture a device \u2014 a robot, a sensor, a camera, a controller. You want it to be discoverable and controllable by AI agents and other devices on a Fabric mesh.</p> <p>This page shows you how to write a device driver, connect your device to a NATS server, and expose typed functions and events that agents can discover and call.</p>"},{"location":"device-connectivity/#what-your-device-becomes","title":"What Your Device Becomes","text":"<p>Once connected, your device:</p> <ul> <li>Self-registers with the device registry (device type, functions, events, identity)</li> <li>Maintains a heartbeat so the mesh knows it's alive</li> <li>Receives RPC calls from agents or other devices (JSON-RPC over NATS)</li> <li>Emits events that agents and other devices can subscribe to</li> <li>Communicates device-to-device without going through a central orchestrator</li> </ul> <p>You write the device logic. The runtime handles registration, heartbeats, messaging, and command routing.</p>"},{"location":"device-connectivity/#installation","title":"Installation","text":"<pre><code>pip install ai-fabric-device\n</code></pre> <p>Four dependencies: <code>nats-py</code>, <code>pydantic</code>, <code>nkeys</code>, <code>pyyaml</code>. Runs on a Raspberry Pi.</p> <p>Optional: <code>pip install \"ai-fabric-device[telemetry]\"</code> adds OpenTelemetry distributed tracing.</p>"},{"location":"device-connectivity/#your-first-device","title":"Your First Device","text":"<p>A complete working device in one file. This temperature sensor exposes one RPC function and emits one event:</p> <pre><code>import asyncio\nfrom fabric_device import DeviceRuntime\nfrom fabric_device.drivers import DeviceDriver, rpc, emit\nfrom fabric_device.types import DeviceIdentity, DeviceStatus\n\n\nclass TemperatureSensor(DeviceDriver):\n    device_type = \"temperature_sensor\"\n\n    @property\n    def identity(self) -&gt; DeviceIdentity:\n        return DeviceIdentity(\n            device_type=\"temperature_sensor\",\n            manufacturer=\"Acme Sensors\",\n            model=\"TH-200\",\n            firmware_version=\"2.1.0\",\n            description=\"Industrial temperature and humidity sensor\",\n        )\n\n    @property\n    def status(self) -&gt; DeviceStatus:\n        return DeviceStatus(\n            location=\"warehouse-B\",\n            availability=\"available\",\n        )\n\n    @rpc()\n    async def get_reading(self) -&gt; dict:\n        \"\"\"Get current temperature and humidity.\n\n        Returns:\n            Dictionary with temperature_c, humidity_pct, and unit.\n        \"\"\"\n        # Replace with your actual hardware read\n        return {\"temperature_c\": 22.5, \"humidity_pct\": 45, \"unit\": \"celsius\"}\n\n    @emit()\n    async def threshold_alert(self, temperature_c: float, threshold: float, severity: str):\n        \"\"\"Temperature exceeded a configured threshold.\n\n        Args:\n            temperature_c: Current temperature reading.\n            threshold: The threshold that was crossed.\n            severity: Alert severity \u2014 warning or critical.\n        \"\"\"\n        pass\n\n    async def connect(self) -&gt; None:\n        # Initialize your hardware, open serial ports, etc.\n        pass\n\n    async def disconnect(self) -&gt; None:\n        # Clean up hardware resources\n        pass\n\n\nasync def main():\n    device = DeviceRuntime(\n        driver=TemperatureSensor(),\n        device_id=\"temp-sensor-001\",\n        messaging_urls=[\"nats://your-server:4222\"],\n        nats_credentials_file=\"/path/to/temp-sensor-001.creds.json\",\n    )\n    await device.run()\n\n\nasyncio.run(main())\n</code></pre> <p>When this runs:</p> <ol> <li>Connects to NATS with JWT authentication</li> <li>Registers with the device registry: \"I am temp-sensor-001, type temperature_sensor, I have <code>get_reading</code> and <code>threshold_alert</code>\"</li> <li>Starts sending heartbeats</li> <li>Listens for incoming RPC calls on <code>fabric.default.temp-sensor-001.cmd</code></li> <li>When an agent calls <code>invoke_device(\"temp-sensor-001\", \"get_reading\")</code>, your <code>get_reading</code> method executes and the result is sent back</li> </ol>"},{"location":"device-connectivity/#writing-a-device-driver","title":"Writing a Device Driver","text":"<p>Your driver is a Python class that extends <code>DeviceDriver</code>. Everything the device can do is declared with decorators.</p>"},{"location":"device-connectivity/#device-identity-and-status","title":"Device Identity and Status","text":"<p>Every device reports who it is and what state it's in. Agents see this when they call <code>discover_devices</code>.</p> <pre><code>from fabric_device.types import DeviceIdentity, DeviceStatus\n\nclass MyRobot(DeviceDriver):\n    device_type = \"cleaning_robot\"\n\n    @property\n    def identity(self) -&gt; DeviceIdentity:\n        return DeviceIdentity(\n            device_type=\"cleaning_robot\",\n            manufacturer=\"RoboCorp\",\n            model=\"CleanBot-3000\",\n            firmware_version=\"4.2.1\",\n            arch=\"aarch64\",\n            description=\"Autonomous floor cleaning robot with chemical handling\",\n        )\n\n    @property\n    def status(self) -&gt; DeviceStatus:\n        return DeviceStatus(\n            location=\"building-A-floor-2\",\n            availability=\"available\",  # or \"busy\", \"offline\", \"maintenance\"\n        )\n</code></pre>"},{"location":"device-connectivity/#rpc-functions-agents-can-call","title":"@rpc \u2014 Functions Agents Can Call","text":"<p>Mark any async method with <code>@rpc()</code> to make it callable over the mesh. The method's name, docstring, and type hints are automatically converted into a function schema that agents can read.</p> <pre><code>from fabric_device.drivers import DeviceDriver, rpc\n\nclass MyRobot(DeviceDriver):\n    device_type = \"cleaning_robot\"\n\n    @rpc()\n    async def start_cleaning(self, zone: str, priority: str = \"normal\") -&gt; dict:\n        \"\"\"Start cleaning a specified zone.\n\n        Args:\n            zone: Target zone ID (e.g., \"zone-A\", \"loading-dock\").\n            priority: Cleaning priority \u2014 normal or urgent.\n\n        Returns:\n            Dictionary with status and estimated_duration_minutes.\n        \"\"\"\n        await self._hardware.start(zone, priority)\n        return {\"status\": \"cleaning\", \"estimated_duration_minutes\": 15}\n\n    @rpc()\n    async def get_battery_level(self) -&gt; dict:\n        \"\"\"Get current battery percentage.\n\n        Returns:\n            Dictionary with battery_pct and charging status.\n        \"\"\"\n        return {\"battery_pct\": 80, \"charging\": False}\n\n    @rpc()\n    async def emergency_stop(self) -&gt; dict:\n        \"\"\"Immediately stop all movement and operations.\n\n        Returns:\n            Dictionary with confirmation status.\n        \"\"\"\n        await self._hardware.halt()\n        return {\"status\": \"stopped\"}\n</code></pre> <p>An agent that calls <code>discover_devices(device_type=\"cleaning_robot\")</code> will see:</p> <pre><code>{\n  \"functions\": [\n    {\n      \"name\": \"start_cleaning\",\n      \"description\": \"Start cleaning a specified zone.\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"zone\": {\"type\": \"string\", \"description\": \"Target zone ID\"},\n          \"priority\": {\"type\": \"string\", \"default\": \"normal\"}\n        }\n      }\n    },\n    {\n      \"name\": \"get_battery_level\",\n      \"description\": \"Get current battery percentage.\"\n    },\n    {\n      \"name\": \"emergency_stop\",\n      \"description\": \"Immediately stop all movement and operations.\"\n    }\n  ]\n}\n</code></pre> <p>Docstrings Matter</p> <p>The function name, docstring, and <code>Args:</code> descriptions are what the AI agent reads to decide when and how to call your function. Write them like you're explaining the function to a person. Clear descriptions lead to better agent decisions.</p>"},{"location":"device-connectivity/#emit-events-your-device-publishes","title":"@emit \u2014 Events Your Device Publishes","text":"<p>Mark a method with <code>@emit()</code> to declare an event. Call the method from your code to publish it. Agents and other devices can subscribe.</p> <pre><code>from fabric_device.drivers import DeviceDriver, emit\n\nclass MyRobot(DeviceDriver):\n    device_type = \"cleaning_robot\"\n\n    @emit()\n    async def cleaning_complete(self, zone: str, duration_minutes: float):\n        \"\"\"Cleaning finished in a zone.\n\n        Args:\n            zone: Zone that was cleaned.\n            duration_minutes: How long the cleaning took.\n        \"\"\"\n        pass  # the body is empty \u2014 the runtime handles publishing\n\n    @emit()\n    async def battery_low(self, battery_pct: int):\n        \"\"\"Battery dropped below threshold.\n\n        Args:\n            battery_pct: Current battery percentage.\n        \"\"\"\n        pass\n</code></pre> <p>Emit events from anywhere in your driver:</p> <pre><code>await self.cleaning_complete(zone=\"zone-A\", duration_minutes=12.5)\nawait self.battery_low(battery_pct=15)\n</code></pre> <p>Events are published to <code>fabric.{tenant}.{device_id}.event.{event_name}</code> on NATS. Any subscriber \u2014 agent or device \u2014 receives them.</p>"},{"location":"device-connectivity/#periodic-background-tasks","title":"@periodic \u2014 Background Tasks","text":"<p>Run a method on a fixed interval. Useful for polling sensors, emitting telemetry, or running health checks.</p> <pre><code>from fabric_device.drivers import DeviceDriver, rpc, emit, periodic\n\nclass TemperatureSensor(DeviceDriver):\n    device_type = \"temperature_sensor\"\n\n    @emit()\n    async def reading(self, temperature_c: float, humidity_pct: float):\n        \"\"\"A new sensor reading.\"\"\"\n        pass\n\n    @emit()\n    async def threshold_alert(self, temperature_c: float, threshold: float, severity: str):\n        \"\"\"Temperature exceeded a threshold.\"\"\"\n        pass\n\n    @periodic(interval=10.0)\n    async def poll_sensor(self):\n        \"\"\"Read sensor every 10 seconds and emit events.\"\"\"\n        data = await self._read_hardware()\n        await self.reading(temperature_c=data[\"temp\"], humidity_pct=data[\"humidity\"])\n\n        if data[\"temp\"] &gt; 40.0:\n            await self.threshold_alert(\n                temperature_c=data[\"temp\"],\n                threshold=40.0,\n                severity=\"critical\",\n            )\n\n    @periodic(interval=60.0)\n    async def health_check(self):\n        \"\"\"Run self-diagnostics every minute.\"\"\"\n        if not self._hardware.is_healthy():\n            self.logger.warning(\"Hardware health check failed\")\n</code></pre>"},{"location":"device-connectivity/#on-listen-to-other-devices","title":"@on \u2014 Listen to Other Devices","text":"<p>Subscribe to events from other devices on the mesh. Your device can react to what's happening around it without going through a central agent.</p> <pre><code>from fabric_device.drivers import DeviceDriver, rpc, on\n\nclass CleaningRobot(DeviceDriver):\n    device_type = \"cleaning_robot\"\n\n    @on(device_type=\"camera\", event_name=\"spill_detected\")\n    async def on_spill(self, device_id: str, event_name: str, payload: dict):\n        \"\"\"React when any camera detects a spill.\"\"\"\n        zone = payload.get(\"zone\")\n        self.logger.info(f\"Spill detected by {device_id} in {zone}\")\n        await self.start_cleaning(zone=zone)\n\n    @on(device_type=\"cleaning_robot\", event_name=\"cleaning_complete\")\n    async def on_peer_done(self, device_id: str, event_name: str, payload: dict):\n        \"\"\"Track when other robots finish cleaning.\"\"\"\n        self.logger.info(f\"{device_id} finished cleaning {payload.get('zone')}\")\n\n    @rpc()\n    async def start_cleaning(self, zone: str) -&gt; dict:\n        \"\"\"Start cleaning a zone.\"\"\"\n        return {\"status\": \"cleaning\", \"zone\": zone}\n</code></pre> <p>This is device-to-device communication. No agent involved. The camera emits <code>spill_detected</code>, the robot receives it directly over NATS and acts.</p>"},{"location":"device-connectivity/#before_emit-intercept-events","title":"@before_emit \u2014 Intercept Events","text":"<p>Filter or modify events before they're published. Return <code>False</code> to suppress an event.</p> <pre><code>from fabric_device.drivers import DeviceDriver, emit, before_emit\n\nclass NoisySensor(DeviceDriver):\n    device_type = \"sensor\"\n\n    @emit()\n    async def reading(self, value: float):\n        \"\"\"A sensor reading.\"\"\"\n        pass\n\n    @before_emit(\"reading\")\n    async def filter_noise(self, value: float, **kwargs):\n        \"\"\"Suppress readings that haven't changed significantly.\"\"\"\n        if hasattr(self, \"_last_value\") and abs(value - self._last_value) &lt; 0.5:\n            return False  # suppress \u2014 don't publish\n        self._last_value = value\n</code></pre>"},{"location":"device-connectivity/#lifecycle-methods","title":"Lifecycle Methods","text":"<p>Every driver has <code>connect</code> and <code>disconnect</code>. Use them to initialize and clean up hardware resources.</p> <pre><code>class MyRobot(DeviceDriver):\n    device_type = \"robot\"\n\n    async def connect(self) -&gt; None:\n        \"\"\"Called after NATS connection is established, before RPCs start.\"\"\"\n        self._hardware = await RobotSDK.connect(\"/dev/ttyUSB0\")\n        self.logger.info(\"Hardware initialized\")\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Called during shutdown, before NATS disconnects.\"\"\"\n        await self._hardware.close()\n        self.logger.info(\"Hardware released\")\n</code></pre>"},{"location":"device-connectivity/#running-the-device","title":"Running the Device","text":""},{"location":"device-connectivity/#deviceruntime","title":"DeviceRuntime","text":"<p><code>DeviceRuntime</code> handles everything outside your driver logic: NATS connection, JWT authentication, device registration, heartbeats, command routing.</p> <pre><code>from fabric_device import DeviceRuntime\n\ndevice = DeviceRuntime(\n    driver=MyRobot(),\n    device_id=\"robot-001\",\n    messaging_urls=[\"nats://your-server:4222\"],\n    nats_credentials_file=\"~/.fabric/credentials/robot-001.creds.json\",\n    tenant=\"default\",\n)\nawait device.run()\n</code></pre> Parameter Type Description <code>driver</code> <code>DeviceDriver</code> Your driver instance <code>device_id</code> <code>str</code> Unique device identifier on the mesh <code>messaging_urls</code> <code>list[str]</code> NATS server URLs <code>nats_credentials_file</code> <code>str \\| None</code> Path to <code>.creds.json</code> for JWT auth <code>tenant</code> <code>str</code> Namespace / zone (default: <code>\"default\"</code>) <code>allow_insecure</code> <code>bool</code> Skip auth for local development (default: <code>False</code>)"},{"location":"device-connectivity/#credentials","title":"Credentials","text":"<p>Devices authenticate to NATS using JWT + NKey credentials. A <code>.creds.json</code> file:</p> <pre><code>{\n  \"device_id\": \"robot-001\",\n  \"auth_type\": \"jwt\",\n  \"tenant\": \"default\",\n  \"nats\": {\n    \"urls\": [\"nats://your-server:4222\"],\n    \"jwt\": \"eyJ0eXAiOiJKV1Qi...\",\n    \"nkey_seed\": \"SUAE...\"\n  }\n}\n</code></pre> <p>Credentials are provisioned by the Fabric administrator and determine:</p> <ul> <li>Which NATS subjects the device can publish/subscribe to</li> <li>Which tenant namespace it operates in</li> <li>Its identity for JWT authentication</li> </ul> <p>Development Mode</p> <p>For local development without auth, use <code>allow_insecure=True</code>. Never use this in production.</p> <pre><code>device = DeviceRuntime(\n    driver=MyRobot(),\n    device_id=\"robot-001\",\n    messaging_urls=[\"nats://localhost:4222\"],\n    allow_insecure=True,\n)\n</code></pre>"},{"location":"device-connectivity/#device-to-device-communication","title":"Device-to-Device Communication","text":"<p>Every <code>DeviceDriver</code> has built-in methods for talking to other devices on the mesh. No agent required.</p>"},{"location":"device-connectivity/#invoke_remote-call-another-device","title":"invoke_remote \u2014 Call Another Device","text":"<pre><code>class Camera(DeviceDriver):\n    device_type = \"camera\"\n\n    @rpc()\n    async def on_motion(self, zone: str) -&gt; dict:\n        \"\"\"Motion detected \u2014 dispatch a robot.\"\"\"\n        robots = await self.list_devices(device_type=\"cleaning_robot\")\n        if robots:\n            result = await self.invoke_remote(\n                robots[0][\"device_id\"],\n                \"start_cleaning\",\n                zone=zone,\n            )\n            return {\"dispatched\": True, \"result\": result}\n        return {\"dispatched\": False, \"reason\": \"no robots available\"}\n</code></pre>"},{"location":"device-connectivity/#list_devices-query-the-registry","title":"list_devices \u2014 Query the Registry","text":"<pre><code># All devices\nall_devices = await self.list_devices()\n\n# Filter by type\nrobots = await self.list_devices(device_type=\"cleaning_robot\")\n\n# Filter by location\nlocal = await self.list_devices(location=\"building-A\")\n</code></pre>"},{"location":"device-connectivity/#what-happens-at-runtime","title":"What Happens at Runtime","text":"<p>When <code>device.run()</code> is called, this is the sequence:</p> <ol> <li>Connect to NATS \u2014 authenticates with JWT + NKey</li> <li>Connect driver \u2014 calls your <code>connect()</code> method</li> <li>Register \u2014 sends device identity, functions, and events to the registry</li> <li>Subscribe to commands \u2014 listens on <code>fabric.{tenant}.{device_id}.cmd</code></li> <li>Start periodic tasks \u2014 any <code>@periodic</code> methods begin running</li> <li>Start event subscriptions \u2014 any <code>@on</code> handlers are wired up</li> <li>Heartbeat loop \u2014 periodic heartbeats keep the registration alive</li> </ol> <p>From this point, your device is live on the mesh. Agents can discover it and call its functions. Other devices can send it events. Your periodic tasks run in the background.</p> <p>When <code>device.stop()</code> is called (or Ctrl+C):</p> <ol> <li>Periodic tasks stop</li> <li>Event subscriptions tear down</li> <li>Your <code>disconnect()</code> method runs</li> <li>NATS connection closes</li> </ol>"},{"location":"device-connectivity/#decorator-summary","title":"Decorator Summary","text":"Decorator What it does <code>@rpc()</code> Expose a method as a remotely callable function (agent or D2D) <code>@emit()</code> Declare an event that can be published to subscribers <code>@periodic(interval=N)</code> Run a method every N seconds in the background <code>@on(device_type=..., event_name=...)</code> Subscribe to events from other devices <code>@before_emit(\"event_name\")</code> Intercept and filter/modify an event before publishing"},{"location":"infrastructure-setup/","title":"Fabric Mesh Setup","text":"<p>You're the administrator. You need to stand up the Fabric mesh so that devices can register and agents can discover them.</p> <p>The infrastructure has three services:</p> Service What it does Port NATS Message routing between devices and agents (JWT auth, TLS) 4222 etcd Stores device registrations with TTL leases 2379 Device Registry Service Listens for device registrations, tracks heartbeats, publishes online/offline events 8080"},{"location":"infrastructure-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker and Docker Compose</li> <li><code>nsc</code> \u2014 the NATS CLI tool for JWT/NKey management (<code>brew install nsc</code> or <code>go install github.com/nats-io/nsc/v2@latest</code>)</li> <li><code>ai-fabric-core</code> installed (<code>pip install \"ai-fabric-core[security]\"</code>)</li> </ul>"},{"location":"infrastructure-setup/#start-the-services","title":"Start the Services","text":"<pre><code>docker compose up nats-jwt etcd device-registry-service -d\n</code></pre> <p>This starts:</p> <ul> <li>nats-jwt \u2014 NATS 2.10 with JWT authentication enabled, using a generated resolver config</li> <li>etcd \u2014 v3.5 key-value store for device registration persistence</li> <li>device-registry-service \u2014 Python service that bridges NATS and etcd</li> </ul>"},{"location":"infrastructure-setup/#verify-services-are-running","title":"Verify Services Are Running","text":"<pre><code>docker ps --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\"\n</code></pre> <pre><code>NAMES                    STATUS              PORTS\ndevice-registry-service  Up 5 minutes        0.0.0.0:8080-&gt;8080/tcp\nnats-jwt                 Up 5 minutes        0.0.0.0:4222-&gt;4222/tcp, 6222/tcp, 8222/tcp\netcd                     Up 5 minutes        0.0.0.0:2379-2380-&gt;2379-2380/tcp\n</code></pre>"},{"location":"infrastructure-setup/#jwt-authentication-setup","title":"JWT Authentication Setup","text":"<p>NATS uses JWT + NKey authentication. Every device and agent gets a signed JWT that defines what NATS subjects it can publish and subscribe to.</p>"},{"location":"infrastructure-setup/#one-time-setup","title":"One-Time Setup","text":"<p>Initialize the NSC operator, account, and signing keys:</p> <pre><code># Set up the NATS JWT infrastructure\n./setup_jwt_auth.sh dev\n\n# Generate credentials for all built-in roles\n./gen_creds.sh --all --force\n</code></pre> <p>This creates:</p> <pre><code>security_infra/\n\u251c\u2500\u2500 credentials/\n\u2502   \u251c\u2500\u2500 devctl.creds.json          # Admin CLI credentials\n\u2502   \u251c\u2500\u2500 orchestrator.creds.json    # Agent/orchestrator credentials\n\u2502   \u2514\u2500\u2500 registry.creds.json        # Registry service credentials\n\u251c\u2500\u2500 certs/\n\u2502   \u2514\u2500\u2500 ca-cert.pem                # TLS CA certificate (if TLS enabled)\n\u2514\u2500\u2500 nats-jwt-generated.conf        # Generated NATS server config\n</code></pre> <p>nats-jwt-generated.conf Must Be a File</p> <p>Docker mounts this file into the NATS container. If it doesn't exist when you first run <code>docker compose up</code>, Docker will auto-create it as a directory, which breaks the mount. Always run <code>setup_jwt_auth.sh</code> before starting Docker. If you see mount errors, remove the directory and regenerate:</p> <pre><code>rm -rf security_infra/nats-jwt-generated.conf\n./setup_jwt_auth.sh dev\n./gen_creds.sh --all --force\n</code></pre>"},{"location":"infrastructure-setup/#credential-file-format","title":"Credential File Format","text":"<p>Each <code>.creds.json</code> file contains everything a client needs to authenticate:</p> <pre><code>{\n  \"device_id\": \"devctl\",\n  \"auth_type\": \"jwt\",\n  \"tenant\": \"default\",\n  \"nats\": {\n    \"urls\": [\"nats://nats-jwt:4222\"],\n    \"jwt\": \"eyJ0eXAiOiJKV1Qi...\",\n    \"nkey_seed\": \"SUAE...\"\n  }\n}\n</code></pre> <p>The JWT encodes:</p> <ul> <li>Which NATS subjects this client can publish to</li> <li>Which subjects it can subscribe to</li> <li>Expiry time (default: 90 days)</li> <li>Account and user identity</li> </ul>"},{"location":"infrastructure-setup/#device-registry-service","title":"Device Registry Service","text":"<p>The registry service is a Python process that runs inside Docker. It:</p> <ol> <li>Subscribes to <code>fabric.{tenant}.registry</code> for device registration RPCs</li> <li>Subscribes to <code>fabric.{tenant}.discovery</code> for device discovery queries</li> <li>Subscribes to <code>fabric.{tenant}.*.heartbeat</code> for device heartbeats</li> <li>Stores device records in etcd with TTL leases</li> <li>Publishes <code>device/online</code> and <code>device/offline</code> events when devices join or leave</li> </ol>"},{"location":"infrastructure-setup/#configuration","title":"Configuration","text":"Environment Variable Description Default <code>TENANT</code> Single tenant namespace <code>default</code> <code>TENANTS</code> Comma-separated list for multi-tenant \u2014 <code>NATS_CREDENTIALS_FILE</code> Path to registry <code>.creds.json</code> \u2014 <code>NATS_URLS</code> NATS server URLs <code>nats://nats-jwt:4222</code> <code>ETCD_HOST</code> etcd hostname <code>etcd</code> <code>ETCD_PORT</code> etcd port <code>2379</code>"},{"location":"infrastructure-setup/#what-gets-stored-in-etcd","title":"What Gets Stored in etcd","text":"<p>Each device registration creates a key at <code>/fabric/{tenant}/devices/{device_id}</code>:</p> <pre><code>{\n  \"device_id\": \"robot-001\",\n  \"device_type\": \"cleaning_robot\",\n  \"device_ttl\": 15,\n  \"capabilities\": {\n    \"functions\": [\n      {\n        \"name\": \"start_cleaning\",\n        \"description\": \"Start cleaning a zone.\",\n        \"parameters\": { \"type\": \"object\", \"properties\": { \"zone\": { \"type\": \"string\" } } }\n      }\n    ],\n    \"events\": [\n      { \"name\": \"cleaning_complete\", \"description\": \"Cleaning finished.\" }\n    ]\n  },\n  \"identity\": {\n    \"device_type\": \"cleaning_robot\",\n    \"manufacturer\": \"RoboCorp\",\n    \"model\": \"CleanBot-3000\",\n    \"firmware_version\": \"4.2.1\"\n  },\n  \"status\": {\n    \"location\": \"warehouse-B\",\n    \"availability\": \"available\"\n  },\n  \"registry\": {\n    \"device_registration_id\": \"a1b2c3d4-...\",\n    \"registered_at\": \"2026-02-20T10:30:00Z\"\n  }\n}\n</code></pre> <p>The record has an etcd lease with TTL. If the device stops sending heartbeats, the lease expires and the registry publishes a <code>device/offline</code> event.</p>"},{"location":"infrastructure-setup/#nats-topic-structure","title":"NATS Topic Structure","text":"<p>All messaging follows this pattern:</p> <pre><code>fabric.{tenant}.{device_id}.cmd              \u2190 RPC calls to a device\nfabric.{tenant}.{device_id}.event.{name}     \u2190 Events from a device\nfabric.{tenant}.{device_id}.heartbeat        \u2190 Device heartbeats\nfabric.{tenant}.registry                     \u2190 Device registration RPCs\nfabric.{tenant}.discovery                    \u2190 Device discovery queries\nfabric.{tenant}.device.online                \u2190 Registry: device came online\nfabric.{tenant}.device.offline               \u2190 Registry: device went offline\n</code></pre>"},{"location":"infrastructure-setup/#device-commissioning","title":"Device Commissioning","text":"<p>New devices need credentials before they can join the mesh. The commissioning flow is:</p>"},{"location":"infrastructure-setup/#1-factory-provisioning","title":"1. Factory Provisioning","text":"<p>Generate a device identity with a factory PIN:</p> <pre><code>python provision_device.py \\\n  --device-id robot-001 \\\n  --device-type cleaning_robot \\\n  --capabilities start_cleaning,stop_cleaning,get_battery_level\n</code></pre> <p>This produces a <code>robot-001.identity.json</code> that gets burned onto the device. It contains:</p> <ul> <li>Device ID and type</li> <li>Ed25519 NKey keypair (public key + seed)</li> <li>8-digit factory PIN (bcrypt-hashed)</li> <li><code>commissioned: false</code></li> </ul>"},{"location":"infrastructure-setup/#2-commission-the-device","title":"2. Commission the Device","text":"<p>The device boots, reads its identity file, sees <code>commissioned: false</code>, and starts an HTTP commissioning server on port 5540.</p> <p>From your admin workstation:</p> Auto-discover via mDNSSpecify device IP <pre><code># Find uncommissioned devices on the local network\ndevctl discover --timeout 5\n\n# Commission with PIN (device found via mDNS)\ndevctl commission robot-001 --pin 12345678\n</code></pre> <pre><code>devctl commission robot-001 \\\n  --pin 12345678 \\\n  --device-ip 192.168.1.50\n</code></pre> <p>What happens:</p> <ol> <li><code>devctl</code> contacts the device at <code>http://{ip}:5540/info</code> to get its NKey public key</li> <li>Generates a JWT signed for this device</li> <li>POSTs the JWT + credentials to <code>http://{ip}:5540/commission</code> with the PIN</li> <li>Device validates the PIN (bcrypt, 3 attempts max, 1-hour lockout)</li> <li>Device saves credentials to disk (<code>~/.fabric/credentials/robot-001.creds.json</code>)</li> <li>Device connects to NATS and self-registers</li> </ol>"},{"location":"infrastructure-setup/#3-verify","title":"3. Verify","text":"<pre><code>devctl list\n</code></pre> <p>The device should appear in the registry.</p>"},{"location":"infrastructure-setup/#admin-cli-devctl","title":"Admin CLI \u2014 devctl","text":"<p><code>devctl</code> is the admin command-line tool for managing the Fabric mesh. Installed with <code>ai-fabric-core</code>.</p>"},{"location":"infrastructure-setup/#list-devices","title":"List Devices","text":"<pre><code># Full output\ndevctl list\n\n# Compact \u2014 one line per device with functions and events\ndevctl list --compact\n</code></pre>"},{"location":"infrastructure-setup/#discover-uncommissioned-devices","title":"Discover Uncommissioned Devices","text":"<pre><code>devctl discover --timeout 10\n</code></pre> <p>Scans the local network via mDNS for devices running commissioning servers.</p> <p>Requires ai-fabric-core[security]</p> <p>Discovery and commissioning require the security extras: <code>pip install \"ai-fabric-core[security]\"</code></p>"},{"location":"infrastructure-setup/#commission-a-device","title":"Commission a Device","text":"<pre><code>devctl commission &lt;device_id&gt; --pin &lt;pin&gt; [--device-ip &lt;ip&gt;]\n</code></pre>"},{"location":"infrastructure-setup/#register-a-test-device","title":"Register a Test Device","text":"<p>For testing without real hardware:</p> <pre><code># Register and immediately exit\ndevctl register --id test-device-001\n\n# Register and keep alive (sends heartbeats)\ndevctl register --id test-device-001 --keepalive\n</code></pre>"},{"location":"infrastructure-setup/#interactive-repl","title":"Interactive REPL","text":"<pre><code>devctl interactive\n</code></pre> <p>Opens an interactive session for calling device functions, listing devices, and debugging the mesh.</p>"},{"location":"infrastructure-setup/#configuration_1","title":"Configuration","text":"<p><code>devctl</code> reads from environment variables:</p> Variable Description Default <code>NATS_URL</code> NATS server URL <code>nats://localhost:4222</code> <code>NATS_CREDENTIALS_FILE</code> Admin credentials file auto-discover <code>TENANT</code> Namespace <code>default</code> <code>DEVICE_TTL</code> Heartbeat timeout (seconds) <code>15</code>"},{"location":"infrastructure-setup/#multi-tenancy","title":"Multi-Tenancy","text":"<p>The mesh supports multiple tenants. Each tenant is a separate namespace \u2014 devices in one tenant are invisible to another.</p> <pre><code># Registry service handles multiple tenants\nTENANTS=warehouse,factory,lab docker compose up device-registry-service -d\n</code></pre> <p>NATS subject scoping ensures isolation:</p> <ul> <li>Warehouse agent credentials: can only access <code>fabric.warehouse.*</code></li> <li>Factory agent credentials: can only access <code>fabric.factory.*</code></li> </ul> <p>Tenant scoping is enforced at the NATS JWT level. Even if an agent knows a device ID in another tenant, the NATS server will deny the message.</p>"},{"location":"infrastructure-setup/#monitoring","title":"Monitoring","text":""},{"location":"infrastructure-setup/#nats-monitoring","title":"NATS Monitoring","text":"<p>NATS exposes an HTTP monitoring endpoint on port 8222:</p> <pre><code># Server info\ncurl http://localhost:8222/varz\n\n# Active connections\ncurl http://localhost:8222/connz\n\n# Active subscriptions\ncurl http://localhost:8222/subsz\n</code></pre>"},{"location":"infrastructure-setup/#etcd-check-device-registrations","title":"etcd \u2014 Check Device Registrations","text":"<pre><code># List all devices in default tenant\netcdctl get /fabric/default/devices/ --prefix --print-value-only | python -m json.tool\n\n# Watch for registration changes\netcdctl watch /fabric/default/devices/ --prefix\n</code></pre>"},{"location":"infrastructure-setup/#device-onlineoffline-events","title":"Device Online/Offline Events","text":"<p>Subscribe to registry lifecycle events:</p> <pre><code># Using nats CLI\nnats sub \"fabric.default.device.&gt;\"\n</code></pre> <p>You'll see <code>device/online</code> when a device registers and <code>device/offline</code> when its heartbeat lease expires.</p>"},{"location":"infrastructure-setup/#security-checklist","title":"Security Checklist","text":"<p>Before going to production:</p> <ul> <li>[ ] TLS enabled on NATS (<code>tls://</code> URLs, CA certificates distributed)</li> <li>[ ] Credential files have <code>0600</code> permissions (owner read/write only)</li> <li>[ ] NSC keys backed up and stored securely</li> <li>[ ] JWT expiry set to a reasonable window (not indefinite)</li> <li>[ ] Each device has unique credentials (no shared JWTs)</li> <li>[ ] <code>allow_insecure=False</code> on all production devices</li> <li>[ ] Multi-tenant scoping if running multiple fleets</li> <li>[ ] etcd authentication enabled</li> <li>[ ] Commissioning PINs are single-use and randomly generated</li> </ul>"},{"location":"strands-integration/","title":"Strands Integration","text":"<p>Give your Strands agent the ability to discover and control physical devices \u2014 robots, cameras, sensors, industrial controllers \u2014 over a NATS messaging mesh.</p> <p>Your devices are already on the network, exposing typed functions. The <code>ai-fabric-tools</code> SDK lets your agent see them and call them.</p>"},{"location":"strands-integration/#what-you-get","title":"What You Get","text":"<ul> <li><code>discover_devices</code> \u2014 see every device on the mesh, its functions, parameter schemas, and current status</li> <li><code>invoke_device</code> \u2014 call any function on any device by name and get the result back</li> <li><code>invoke_device_with_fallback</code> \u2014 try a list of devices in order until one succeeds</li> <li><code>get_device_status</code> \u2014 check a specific device before acting on it</li> </ul> <p>These are standard Strands tools. They show up in your agent's tool list alongside anything else you provide. The agent decides when to use them as part of its normal reasoning.</p>"},{"location":"strands-integration/#installation","title":"Installation","text":"<pre><code>pip install ai-fabric-tools[strands]\n</code></pre>"},{"location":"strands-integration/#prerequisites","title":"Prerequisites","text":"<p>You need:</p> <ol> <li>A running NATS server with devices connected (your Fabric mesh)</li> <li>A credentials file (<code>.creds.json</code>) that grants your agent access to the devices it needs</li> <li>An <code>ANTHROPIC_API_KEY</code> for your Strands agent</li> </ol>"},{"location":"strands-integration/#connect-and-go","title":"Connect and Go","text":"<pre><code>from ai_fabric_tools import connect\nfrom ai_fabric_tools.adapters.strands import discover_devices, invoke_device\nfrom strands import Agent\nfrom strands.models.anthropic import AnthropicModel\n\nconnect(\n    nats_url=\"nats://your-server:4222\",\n    credentials=\"/path/to/agent.creds.json\",\n)\n\nagent = Agent(\n    model=AnthropicModel(model_id=\"us.anthropic.claude-sonnet-4-5-20250929-v1:0\"),\n    tools=[discover_devices, invoke_device],\n    system_prompt=\"You are an assistant that monitors and controls IoT devices.\",\n)\n\nagent(\"What devices are online? Check the battery level of any robots you find.\")\n</code></pre> <p>The agent will call <code>discover_devices</code> to see what's available, then call <code>invoke_device</code> to check battery levels. You didn't write that logic \u2014 the model figured it out from the tool descriptions and the device function schemas.</p>"},{"location":"strands-integration/#connection-options","title":"Connection Options","text":"<p>You can configure the connection explicitly or through environment variables:</p> Environment VariablesExplicit <pre><code>export NATS_URL=nats://your-server:4222\nexport NATS_CREDENTIALS_FILE=/path/to/agent.creds.json\nexport TENANT=default\n</code></pre> <pre><code>from ai_fabric_tools import connect\nconnect()  # picks up env vars automatically\n</code></pre> <pre><code>from ai_fabric_tools import connect\nconnect(\n    nats_url=\"nats://your-server:4222\",\n    credentials=\"/path/to/agent.creds.json\",\n    zone=\"warehouse-east\",\n)\n</code></pre> <p>The connection is lazy \u2014 it opens on the first tool call, not at import time.</p>"},{"location":"strands-integration/#tool-reference","title":"Tool Reference","text":""},{"location":"strands-integration/#discover_devices","title":"discover_devices","text":"<p>See what's on the network.</p> <pre><code>from ai_fabric_tools.adapters.strands import discover_devices\n</code></pre> Parameter Type Description Default <code>device_type</code> <code>str \\| None</code> Filter by type, e.g. <code>\"robot\"</code>, <code>\"camera\"</code> (fuzzy match) <code>None</code> (all) <code>refresh</code> <code>bool</code> Bypass cache and query registry directly <code>False</code> <p>Example response:</p> <pre><code>[\n    {\n        \"device_id\": \"robot-001\",\n        \"device_type\": \"cleaning_robot\",\n        \"location\": \"warehouse-B\",\n        \"status\": {\"availability\": \"available\"},\n        \"functions\": [\n            {\n                \"name\": \"start_cleaning\",\n                \"description\": \"Start cleaning a specified zone.\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"zone\": {\"type\": \"string\", \"description\": \"Target zone ID\"}\n                    }\n                }\n            },\n            {\n                \"name\": \"get_battery_level\",\n                \"description\": \"Returns current battery percentage.\",\n                \"parameters\": {}\n            }\n        ],\n        \"events\": [\"cleaning_complete\", \"battery_low\"]\n    },\n    {\n        \"device_id\": \"camera-002\",\n        \"device_type\": \"vision_camera\",\n        \"location\": \"entrance\",\n        \"status\": {\"availability\": \"available\"},\n        \"functions\": [\n            {\n                \"name\": \"capture_image\",\n                \"description\": \"Capture an image from the camera.\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"resolution\": {\"type\": \"string\", \"default\": \"1080p\"}\n                    }\n                }\n            }\n        ],\n        \"events\": [\"motion_detected\"]\n    }\n]\n</code></pre> <p>The model reads these function schemas and knows exactly what it can call and with what parameters. No manual tool definitions needed on your side.</p> <p>Inject Device Context into the System Prompt</p> <p>For faster first responses, discover devices at startup and put the result in the system prompt. The model starts the conversation already knowing what's available.</p> <pre><code>from ai_fabric_tools import connect, discover_devices as discover\n\nconnect()\ndevices = discover()\n\nagent = Agent(\n    tools=[discover_devices, invoke_device],\n    system_prompt=f\"You control IoT devices. Available devices:\\n\\n{devices}\",\n)\n</code></pre> <p>Or let the agent call <code>discover_devices</code> itself when it needs to \u2014 both patterns work.</p>"},{"location":"strands-integration/#invoke_device","title":"invoke_device","text":"<p>Call a function on a device.</p> <pre><code>from ai_fabric_tools.adapters.strands import invoke_device\n</code></pre> Parameter Type Description Default <code>device_id</code> <code>str</code> Target device, e.g. <code>\"robot-001\"</code> required <code>function</code> <code>str</code> Function to call, e.g. <code>\"start_cleaning\"</code> required <code>params</code> <code>dict \\| None</code> Function parameters <code>None</code> <code>llm_reasoning</code> <code>str \\| None</code> Why the agent is making this call \u2014 logged for observability <code>None</code> <p>Example responses:</p> <pre><code># Success\n{\"success\": True, \"result\": {\"zone\": \"B-7\", \"status\": \"cleaning_in_progress\"}}\n\n# Failure\n{\"success\": False, \"error\": \"Device robot-001 is offline\"}\n</code></pre> <p>The <code>llm_reasoning</code> field is not sent to the device. It's logged on the agent side so you can trace back why the model made a particular call.</p>"},{"location":"strands-integration/#invoke_device_with_fallback","title":"invoke_device_with_fallback","text":"<p>Same as <code>invoke_device</code>, but tries a list of devices in order. Useful when the agent identifies multiple candidates and wants automatic failover.</p> <pre><code>from ai_fabric_tools.adapters.strands import invoke_device_with_fallback\n</code></pre> Parameter Type Description Default <code>device_ids</code> <code>list[str]</code> Devices to try, in preference order required <code>function</code> <code>str</code> Function to call required <code>params</code> <code>dict \\| None</code> Function parameters <code>None</code> <code>llm_reasoning</code> <code>str \\| None</code> Decision rationale <code>None</code> <p>Example responses:</p> <pre><code># Second device succeeded\n{\"success\": True, \"device_id\": \"robot-002\", \"result\": {\"status\": \"cleaning\"}}\n\n# All failed\n{\n    \"success\": False,\n    \"error\": \"All devices failed\",\n    \"failed_devices\": [\n        {\"device_id\": \"robot-001\", \"error\": \"offline\"},\n        {\"device_id\": \"robot-002\", \"error\": \"timeout\"}\n    ]\n}\n</code></pre>"},{"location":"strands-integration/#get_device_status","title":"get_device_status","text":"<p>Check a single device's current state before acting on it.</p> <pre><code>from ai_fabric_tools.adapters.strands import get_device_status\n</code></pre> Parameter Type Description Default <code>device_id</code> <code>str</code> Device to query required <p>Example response:</p> <pre><code>{\n    \"device_id\": \"robot-001\",\n    \"device_type\": \"cleaning_robot\",\n    \"location\": \"warehouse-B\",\n    \"status\": {\"availability\": \"available\"},\n    \"functions\": [\"start_cleaning\", \"stop_cleaning\", \"get_battery_level\"]\n}\n</code></pre>"},{"location":"strands-integration/#example-agent-that-reacts-to-device-events","title":"Example: Agent That Reacts to Device Events","text":"<p>A complete working example. Devices emit events (sensor readings, alerts, status changes). The agent subscribes, batches them, and reasons about what to do.</p> <pre><code>import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\n\nfrom ai_fabric_tools import connect, get_connection\nfrom ai_fabric_tools import discover_devices as discover\nfrom ai_fabric_tools.adapters.strands import (\n    discover_devices,\n    invoke_device,\n    invoke_device_with_fallback,\n    get_device_status,\n)\nfrom strands import Agent\nfrom strands.models.anthropic import AnthropicModel\n\n\ndef build_prompt(events: list[dict]) -&gt; str:\n    lines = []\n    for e in events:\n        device_id = e.get(\"device_id\", \"?\")\n        event_name = e.get(\"event_name\", \"?\")\n        payload = {k: v for k, v in e.items()\n                   if k not in (\"device_id\", \"event_name\", \"event_id\", \"ts\")}\n        lines.append(f\"  {device_id}::{event_name} \u2192 {payload}\")\n\n    return (\n        f\"{len(events)} new device events:\\n\"\n        + \"\\n\".join(lines)\n        + \"\\n\\nAnalyze these events and take action if needed.\"\n    )\n\n\nasync def main():\n    connect()\n    conn = get_connection()\n\n    devices = discover()\n    agent = Agent(\n        model=AnthropicModel(model_id=\"us.anthropic.claude-sonnet-4-5-20250929-v1:0\"),\n        tools=[discover_devices, invoke_device, invoke_device_with_fallback, get_device_status],\n        system_prompt=f\"You monitor IoT devices. Available:\\n\\n{devices}\",\n    )\n\n    executor = ThreadPoolExecutor(max_workers=1)\n\n    async for batch in conn.subscribe_events(batch_window=12.0):\n        if not batch:\n            continue\n\n        prompt = build_prompt(batch)\n        print(f\"\\n--- {len(batch)} events received ---\")\n\n        loop = asyncio.get_running_loop()\n        response = await loop.run_in_executor(\n            executor, lambda p=prompt: str(agent(p))\n        )\n        print(f\"Agent: {response}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>What happens:</p> <ol> <li>Agent connects to the NATS mesh and discovers all devices</li> <li>Subscribes to every device event on the network</li> <li>Events accumulate over a 12-second window</li> <li>Each batch becomes a prompt: \"Here are 5 new events. Analyze and act.\"</li> <li>The agent reads the events, decides what to do, and calls <code>invoke_device</code> if action is needed</li> </ol> <p>Sync/Async Bridge</p> <p>Strands agents are synchronous. NATS event subscriptions are async. The <code>ThreadPoolExecutor</code> bridges the two \u2014 the agent runs in a worker thread while the event loop handles NATS I/O.</p>"},{"location":"strands-integration/#access-control","title":"Access Control","text":"<p>Credentials define what your agent can see and do. A credential scoped to <code>warehouse-east</code> devices will:</p> <ul> <li><code>discover_devices</code> \u2014 only returns warehouse-east devices</li> <li><code>invoke_device</code> \u2014 calls to out-of-scope devices return an authorization error, not a silent failure</li> <li><code>get_device_status</code> \u2014 same scoping</li> </ul> <p>This is enforced at the NATS layer, not in the SDK. The tools don't filter \u2014 the messaging infrastructure does.</p>"},{"location":"strands-integration/#how-it-works-under-the-hood","title":"How It Works Under the Hood","text":"<p>The Strands adapter is thin. Each tool is a plain Python function wrapped with <code>@strands.tool</code>:</p> <pre><code>from strands import tool as strands_tool\nfrom ai_fabric_tools.tools import discover_devices as _discover_devices\n\ndiscover_devices = strands_tool(_discover_devices)\n</code></pre> <p>The core functions use <code>nats-py</code> to send JSON-RPC requests over NATS subjects:</p> <ul> <li>Discovery: <code>fabric.{zone}.discovery</code> \u2192 registry responds with device list</li> <li>Invoke: <code>fabric.{zone}.{device_id}.cmd</code> \u2192 device executes function and responds</li> <li>Events: <code>fabric.{zone}.{device_id}.event.{event_name}</code> \u2192 device publishes, agent subscribes</li> </ul> <p>No HTTP, no REST, no WebSocket. Direct NATS pub/sub with request-reply for RPCs.</p>"},{"location":"strands-integration/#what-these-tools-dont-do","title":"What These Tools Don't Do","text":"<p>The tools are stateless primitives. They do not:</p> <ul> <li>Subscribe to events (use <code>conn.subscribe_events()</code> directly \u2014 see example above)</li> <li>Maintain conversation or device state between calls</li> <li>Batch multiple device calls into one request</li> <li>Run any reasoning or decision logic</li> </ul> <p>All orchestration lives in your agent. Fabric gives your agent reach into the physical world. Your agent decides what to do with it.</p>"}]}